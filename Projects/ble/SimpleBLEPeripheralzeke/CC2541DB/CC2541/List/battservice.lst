###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             11/Mar/2014  15:56:26 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          Profiles\Batt\battservice.c                        #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\config\b #
#                          uildComponents.cfg (-DBROADCASTER_CFG=0x01         #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheralzeke\CC2541DB\buildCo #
#                          nfig.cfg (-DHOST_CONFIG=PERIPHERAL_CFG             #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          Profiles\Batt\battservice.c -D INT_HEAP_LEN=3074   #
#                          -D HALNODEBUG -D OSAL_CBTIMER_NUM_TASKS=1 -D       #
#                          xHAL_AES_DMA=TRUE -D HAL_DMA=TRUE -D POWER_SAVING  #
#                          -D xPLUS_BROADCASTER -D HAL_LCD=TRUE -D            #
#                          HAL_LED=TRUE -D HAL_UART=TRUE -D HAL_ADC=TRUE      #
#                          -lcN E:\TexasInstruments\BLE-CC254x-1.4.0\Projects #
#                          \ble\SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\ #
#                           -o E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\   #
#                          -e --debug --core=plain --dptr=16,1                #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\common\  #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\include\ #
#                           -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\C #
#                          omponents\hal\include\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\hal\target\CC2541EB\ -I                      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\osal\include\ -I E:\TexasInstruments\BLE-CC2 #
#                          54x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2 #
#                          541DB\..\..\..\..\Components\services\saddr\ -I    #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\include\ -I E:\TexasInstruments\BLE-CC25 #
#                          4x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC25 #
#                          41DB\..\..\..\..\Components\ble\controller\phy\    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Co #
#                          mponents\ble\controller\include\ -I                #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\..\..\Components\ble\host\ -I               #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\common\cc25 #
#                          40\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\comm #
#                          on\npi\npi_np\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\Profiles\Roles\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Si #
#                          mpleProfile\ -I E:\TexasInstruments\BLE-CC254x-1.4 #
#                          .0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB\. #
#                          .\..\Profiles\DevInfo\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Ba #
#                          tt\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\Prof #
#                          iles\HIDDev\ -Ohz                                  #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\batts #
#                          ervice.lst                                         #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\battse #
#                          rvice.r51                                          #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\Profiles\Batt\battservice.c
      1          /**************************************************************************************************
      2            Filename:       battservice.c
      3            Revised:        $Date $
      4            Revision:       $Revision $
      5          
      6            Description:    This file contains the Battery service.
      7          
      8            Copyright 2012-2013 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          **************************************************************************************************/
     38          
     39          /*********************************************************************
     40           * INCLUDES
     41           */
     42          #include "bcomdef.h"
     43          #include "OSAL.h"
     44          #include "hal_adc.h"
     45          #include "linkdb.h"
     46          #include "att.h"
     47          #include "gatt.h"
     48          #include "gatt_uuid.h"
     49          #include "gatt_profile_uuid.h"
     50          #include "gattservapp.h"
     51          #include "hiddev.h"
     52          #include "hal_lcd.h"
     53          #include "battservice.h"
     54          #include "hal_led.h"
     55          //#include "SimpleDS18B20.h"
     56          
     57          /*********************************************************************
     58           * MACROS
     59           */
     60          
     61          /*********************************************************************
     62           * CONSTANTS
     63           */
     64          
     65          // ADC voltage levels
     66          #define BATT_ADC_LEVEL_3V           409
     67          #define BATT_ADC_LEVEL_2V           273
     68          
     69          #define BATT_LEVEL_VALUE_IDX        2 // Position of battery level in attribute array
     70          #define BATT_LEVEL_VALUE_CCCD_IDX   3 // Position of battery level CCCD in attribute array
     71          
     72          /*********************************************************************
     73           * TYPEDEFS
     74           */
     75          
     76          /*********************************************************************
     77           * GLOBAL VARIABLES
     78           */
     79          // Battery service
     80          CONST uint8 battServUUID[ATT_BT_UUID_SIZE] =
     81          {
     82            LO_UINT16(BATT_SERV_UUID), HI_UINT16(BATT_SERV_UUID)
     83          };
     84          
     85          // Battery level characteristic
     86          CONST uint8 battLevelUUID[ATT_BT_UUID_SIZE] =
     87          {
     88            LO_UINT16(BATT_LEVEL_UUID), HI_UINT16(BATT_LEVEL_UUID)
     89          };
     90          
     91          /*********************************************************************
     92           * EXTERNAL VARIABLES
     93           */
     94          
     95          /*********************************************************************
     96           * EXTERNAL FUNCTIONS
     97           */
     98          
     99          /*********************************************************************
    100           * LOCAL VARIABLES
    101           */
    102          
    103          // Application callback
    104          static battServiceCB_t battServiceCB;
    105          
    106          // Measurement setup callback
    107          static battServiceSetupCB_t battServiceSetupCB = NULL;
    108          
    109          // Measurement teardown callback
    110          static battServiceTeardownCB_t battServiceTeardownCB = NULL;
    111          
    112          // Measurement calculation callback
    113          static battServiceCalcCB_t battServiceCalcCB = NULL;
    114          
    115          static uint16 battMinLevel = BATT_ADC_LEVEL_2V; // For VDD/3 measurements
    116          static uint16 battMaxLevel = BATT_ADC_LEVEL_3V; // For VDD/3 measurements
    117          
    118          // Critical battery level setting
    119          static uint8 battCriticalLevel;
    120          
    121          // ADC channel to be used for reading
    122          static uint8 battServiceAdcCh = HAL_ADC_CHANNEL_VDD;
    123          
    124          /*********************************************************************
    125           * Profile Attributes - variables
    126           */
    127          
    128          // Battery Service attribute
    129          static CONST gattAttrType_t battService = { ATT_BT_UUID_SIZE, battServUUID };
    130          
    131          // Battery level characteristic
    132          static uint8 battLevelProps = GATT_PROP_READ | GATT_PROP_NOTIFY;
    133          static uint8 battLevel = 100;
    134          static gattCharCfg_t battLevelClientCharCfg[GATT_MAX_NUM_CONN];
    135          
    136          // HID Report Reference characteristic descriptor, battery level
    137          static uint8 hidReportRefBattLevel[HID_REPORT_REF_LEN] =
    138                       { HID_RPT_ID_BATT_LEVEL_IN, HID_REPORT_TYPE_INPUT };
    139          
    140          /*********************************************************************
    141           * Profile Attributes - Table
    142           */
    143          
    144          static gattAttribute_t battAttrTbl[] =
    145          {
    146            // Battery Service
    147            {
    148              { ATT_BT_UUID_SIZE, primaryServiceUUID }, /* type */
    149              GATT_PERMIT_READ,                         /* permissions */
    150              0,                                        /* handle */
    151              (uint8 *)&battService                     /* pValue */
    152            },
    153          
    154              // Battery Level Declaration
    155              {
    156                { ATT_BT_UUID_SIZE, characterUUID },
    157                GATT_PERMIT_READ,
    158                0,
    159                &battLevelProps
    160              },
    161          
    162                // Battery Level Value
    163                {
    164                  { ATT_BT_UUID_SIZE, battLevelUUID },
    165                  GATT_PERMIT_READ,
    166                  0,
    167                  &battLevel
    168                },
    169          
    170                // Battery Level Client Characteristic Configuration
    171                {
    172                  { ATT_BT_UUID_SIZE, clientCharCfgUUID },
    173                  GATT_PERMIT_READ | GATT_PERMIT_WRITE,
    174                  0,
    175                  (uint8 *) &battLevelClientCharCfg
    176                },
    177          
    178                // HID Report Reference characteristic descriptor, batter level input
    179                {
    180                  { ATT_BT_UUID_SIZE, reportRefUUID },
    181                  GATT_PERMIT_READ,
    182                  0,
    183                  hidReportRefBattLevel
    184                }
    185          };
    186          
    187          
    188          /*********************************************************************
    189           * LOCAL FUNCTIONS
    190           */
    191          static uint8 battReadAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
    192                                       uint8 *pValue, uint8 *pLen, uint16 offset, uint8 maxLen );
    193          static bStatus_t battWriteAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
    194                                            uint8 *pValue, uint8 len, uint16 offset );
    195          static void battNotifyCB( linkDBItem_t *pLinkItem );
    196          static uint8 battMeasure( void );
    197          static void battNotifyLevel( void );
    198          /*********************************************************************
    199           * PROFILE CALLBACKS
    200           */
    201          // Battery Service Callbacks
    202          CONST gattServiceCBs_t battCBs =
    203          {
    204            battReadAttrCB,  // Read callback function pointer
    205            battWriteAttrCB, // Write callback function pointer
    206            NULL             // Authorization callback function pointer
    207          };
    208          
    209          /*********************************************************************
    210           * PUBLIC FUNCTIONS
    211           */
    212          /*********************************************************************
    213           * @fn      Batt_AddService
    214           *
    215           * @brief   Initializes the Battery Service by registering
    216           *          GATT attributes with the GATT server.
    217           *
    218           * @return  Success or Failure
    219           */
    220          bStatus_t Batt_AddService( void )
    221          {
    222            uint8 status = SUCCESS;
    223          
    224            // Initialize Client Characteristic Configuration attributes
    225            GATTServApp_InitCharCfg( INVALID_CONNHANDLE, battLevelClientCharCfg );
    226          
    227            // Register GATT attribute list and CBs with GATT Server App
    228            status = GATTServApp_RegisterService( battAttrTbl,
    229                                                  GATT_NUM_ATTRS( battAttrTbl ),
    230                                                  &battCBs );
    231          
    232            return ( status );
    233          }
    234          
    235          /*********************************************************************
    236           * @fn      Batt_Register
    237           *
    238           * @brief   Register a callback function with the Battery Service.
    239           *
    240           * @param   pfnServiceCB - Callback function.
    241           *
    242           * @return  None.
    243           */
    244          extern void Batt_Register( battServiceCB_t pfnServiceCB )
    245          {
    246            battServiceCB = pfnServiceCB;
    247          }
    248          
    249          /*********************************************************************
    250           * @fn      Batt_SetParameter
    251           *
    252           * @brief   Set a Battery Service parameter.
    253           *
    254           * @param   param - Profile parameter ID
    255           * @param   len - length of data to right
    256           * @param   value - pointer to data to write.  This is dependent on
    257           *          the parameter ID and WILL be cast to the appropriate
    258           *          data type (example: data type of uint16 will be cast to
    259           *          uint16 pointer).
    260           *
    261           * @return  bStatus_t
    262           */
    263          bStatus_t Batt_SetParameter( uint8 param, uint8 len, void *value )
    264          {
    265            bStatus_t ret = SUCCESS;
    266          
    267            switch ( param )
    268            {
    269              case BATT_PARAM_CRITICAL_LEVEL:
    270                battCriticalLevel = *((uint8*)value);
    271          
    272                // If below the critical level and critical state not set, notify it
    273                if ( battLevel < battCriticalLevel )
    274                {
    275                  battNotifyLevel();
    276                }
    277                break;
    278          
    279              default:
    280                ret = INVALIDPARAMETER;
    281                break;
    282            }
    283          
    284            return ( ret );
    285          }
    286          
    287          /*********************************************************************
    288           * @fn      Batt_GetParameter
    289           *
    290           * @brief   Get a Battery Service parameter.
    291           *
    292           * @param   param - Profile parameter ID
    293           * @param   value - pointer to data to get.  This is dependent on
    294           *          the parameter ID and WILL be cast to the appropriate
    295           *          data type (example: data type of uint16 will be cast to
    296           *          uint16 pointer).
    297           *
    298           * @return  bStatus_t
    299           */
    300          bStatus_t Batt_GetParameter( uint8 param, void *value )
    301          {
    302            bStatus_t ret = SUCCESS;
    303            switch ( param )
    304            {
    305              case BATT_PARAM_LEVEL:
    306                *((uint8*)value) = battLevel;
    307                break;
    308          
    309              case BATT_PARAM_CRITICAL_LEVEL:
    310                *((uint8*)value) = battCriticalLevel;
    311                break;
    312          
    313              case BATT_PARAM_SERVICE_HANDLE:
    314                *((uint16*)value) = GATT_SERVICE_HANDLE( battAttrTbl );
    315                break;
    316          
    317              case BATT_PARAM_BATT_LEVEL_IN_REPORT:
    318                {
    319                  hidRptMap_t *pRpt = (hidRptMap_t *)value;
    320          
    321                  pRpt->id = hidReportRefBattLevel[0];
    322                  pRpt->type = hidReportRefBattLevel[1];
    323                  pRpt->handle = battAttrTbl[BATT_LEVEL_VALUE_IDX].handle;
    324                  pRpt->cccdHandle = battAttrTbl[BATT_LEVEL_VALUE_CCCD_IDX].handle;
    325                  pRpt->mode = HID_PROTOCOL_MODE_REPORT;
    326                }
    327                break;
    328          
    329              default:
    330                ret = INVALIDPARAMETER;
    331                break;
    332            }
    333          
    334            return ( ret );
    335          }
    336          
    337          /*********************************************************************
    338           * @fn          Batt_MeasLevel
    339           *
    340           * @brief       Measure the battery level and update the battery
    341           *              level value in the service characteristics.  If
    342           *              the battery level-state characteristic is configured
    343           *              for notification and the battery level has changed
    344           *              since the last measurement, then a notification
    345           *              will be sent.
    346           *
    347           * @return      Success
    348           */
    349          bStatus_t Batt_MeasLevel( void )
    350          {
    351          
    352            
    353            uint8 level;
    354          HalLcdWriteString("now  start batt..", HAL_LCD_LINE_7);
    355            level = battMeasure();
    356          HalLcdWriteStringValue("batt_lebel:", level, 10, HAL_LCD_LINE_8);
    357            // If level has gone down
    358            if (level < battLevel)
    359            {
    360              // Update level
    361              battLevel = level;
    362          
    363              // Send a notification
    364              battNotifyLevel();
    365            }
    366          
    367            return SUCCESS;
    368          }
    369          
    370          /*********************************************************************
    371           * @fn      Batt_Setup
    372           *
    373           * @brief   Set up which ADC source is to be used. Defaults to VDD/3.
    374           *
    375           * @param   adc_ch - ADC Channel, e.g. HAL_ADC_CHN_AIN6
    376           * @param   minVal - max battery level
    377           * @param   maxVal - min battery level
    378           * @param   sCB - HW setup callback
    379           * @param   tCB - HW tear down callback
    380           * @param   cCB - percentage calculation callback
    381           *
    382           * @return  none.
    383           */
    384          void Batt_Setup( uint8 adc_ch, uint16 minVal, uint16 maxVal,
    385                           battServiceSetupCB_t sCB, battServiceTeardownCB_t tCB,
    386                           battServiceCalcCB_t cCB )
    387          {
    388            battServiceAdcCh = adc_ch;
    389            battMinLevel = minVal;
    390            battMaxLevel = maxVal;
    391          
    392            battServiceSetupCB = sCB;
    393            battServiceTeardownCB = tCB;
    394            battServiceCalcCB = cCB;
    395          }
    396          
    397          /*********************************************************************
    398           * @fn          battReadAttrCB
    399           *
    400           * @brief       Read an attribute.
    401           *
    402           * @param       connHandle - connection message was received on
    403           * @param       pAttr - pointer to attribute
    404           * @param       pValue - pointer to data to be read
    405           * @param       pLen - length of data to be read
    406           * @param       offset - offset of the first octet to be read
    407           * @param       maxLen - maximum length of data to be read
    408           *
    409           * @return      Success or Failure
    410           */
    411          static uint8 battReadAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
    412                                       uint8 *pValue, uint8 *pLen, uint16 offset, uint8 maxLen )
    413          {
    414            bStatus_t status = SUCCESS;
    415          
    416            // Make sure it's not a blob operation (no attributes in the profile are long)
    417            if ( offset > 0 )
    418            {
    419              return ( ATT_ERR_ATTR_NOT_LONG );
    420            }
    421          
    422            uint16 uuid = BUILD_UINT16( pAttr->type.uuid[0], pAttr->type.uuid[1] );
    423          
    424            // Measure battery level if reading level
    425            if ( uuid == BATT_LEVEL_UUID )
    426            {
    427              uint8 level;
    428          
    429              level = battMeasure();
    430          
    431              // If level has gone down
    432              if (level < battLevel)
    433              {
    434                // Update level
    435                battLevel = level;
    436              }
    437          
    438              *pLen = 1;
    439              pValue[0] = battLevel;
    440            }
    441            else if ( uuid == GATT_REPORT_REF_UUID )
    442            {
    443              *pLen = HID_REPORT_REF_LEN;
    444              osal_memcpy( pValue, pAttr->pValue, HID_REPORT_REF_LEN );
    445            }
    446            else
    447            {
    448              status = ATT_ERR_ATTR_NOT_FOUND;
    449            }
    450          
    451            return ( status );
    452          }
    453          
    454          /*********************************************************************
    455           * @fn      battWriteAttrCB
    456           *
    457           * @brief   Validate attribute data prior to a write operation
    458           *
    459           * @param   connHandle - connection message was received on
    460           * @param   pAttr - pointer to attribute
    461           * @param   pValue - pointer to data to be written
    462           * @param   len - length of data
    463           * @param   offset - offset of the first octet to be written
    464           *
    465           * @return  Success or Failure
    466           */
    467          static bStatus_t battWriteAttrCB( uint16 connHandle, gattAttribute_t *pAttr,
    468                                            uint8 *pValue, uint8 len, uint16 offset )
    469          {
    470            bStatus_t status = SUCCESS;
    471          
    472            uint16 uuid = BUILD_UINT16( pAttr->type.uuid[0], pAttr->type.uuid[1]);
    473            switch ( uuid )
    474            {
    475              case GATT_CLIENT_CHAR_CFG_UUID:
    476                status = GATTServApp_ProcessCCCWriteReq( connHandle, pAttr, pValue, len,
    477                                                         offset, GATT_CLIENT_CFG_NOTIFY );
    478                if ( status == SUCCESS )
    479                {
    480                  uint16 charCfg = BUILD_UINT16( pValue[0], pValue[1] );
    481          
    482                  if ( battServiceCB )
    483                  {
    484                    (*battServiceCB)( (charCfg == GATT_CFG_NO_OPERATION) ?
    485                                      BATT_LEVEL_NOTI_DISABLED :
    486                                      BATT_LEVEL_NOTI_ENABLED);
    487                  }
    488                }
    489                break;
    490          
    491              default:
    492                status = ATT_ERR_ATTR_NOT_FOUND;
    493                break;
    494            }
    495          
    496            return ( status );
    497          }
    498          
    499          /*********************************************************************
    500           * @fn          battNotifyCB
    501           *
    502           * @brief       Send a notification of the level state characteristic.
    503           *
    504           * @param       connHandle - linkDB item
    505           *
    506           * @return      None.
    507           */
    508          static void battNotifyCB( linkDBItem_t *pLinkItem )
    509          {
    510            if ( pLinkItem->stateFlags & LINK_CONNECTED )
    511            {
    512              uint16 value = GATTServApp_ReadCharCfg( pLinkItem->connectionHandle,
    513                                                      battLevelClientCharCfg );
    514              if ( value & GATT_CLIENT_CFG_NOTIFY )
    515              {
    516                attHandleValueNoti_t noti;
    517          
    518                noti.handle = battAttrTbl[BATT_LEVEL_VALUE_IDX].handle;
    519                noti.len = 1;
    520                noti.value[0] = battLevel;
    521          
    522                GATT_Notification( pLinkItem->connectionHandle, &noti, FALSE );
    523              }
    524            }
    525          }
    526          
    527          /*********************************************************************
    528           * @fn      battMeasure
    529           *
    530           * @brief   Measure the battery level with the ADC and return
    531           *          it as a percentage 0-100%.
    532           *
    533           * @return  Battery level.
    534           */
    535          static uint8 battMeasure( void )
    536          {
    537            uint16 adc;
    538            uint8 percent;
    539          
    540            /**
    541             * Battery level conversion from ADC to a percentage:
    542             *
    543             * The maximum ADC value for the battery voltage level is 511 for a
    544             * 10-bit conversion.  The ADC value is references vs. 1.25v and
    545             * this maximum value corresponds to a voltage of 3.75v.
    546             *
    547             * For a coin cell battery 3.0v = 100%.  The minimum operating
    548             * voltage of the CC2540 is 2.0v so 2.0v = 0%.
    549             *
    550             * To convert a voltage to an ADC value use:
    551             *
    552             *   (v/3)/1.25 * 511 = adc
    553             *
    554             * 3.0v = 409 ADC
    555             * 2.0v = 273 ADC
    556             *
    557             * We need to map ADC values from 409-273 to 100%-0%.
    558             *
    559             * Normalize the ADC values to zero:
    560             *
    561             * 409 - 273 = 136
    562             *
    563             * And convert ADC range to percentage range:
    564             *
    565             * percent/adc = 100/136 = 25/34
    566             *
    567             * Resulting in the final equation, with round:
    568             *
    569             * percent = ((adc - 273) * 25) + 33 / 34
    570             */
    571          
    572            // Call measurement setup callback
    573            if (battServiceSetupCB != NULL)
    574            {
    575              battServiceSetupCB();
    576            }
    577          
    578            // Configure ADC and perform a read
    579            HalAdcSetReference( HAL_ADC_REF_125V );
    580            adc = HalAdcRead( battServiceAdcCh, HAL_ADC_RESOLUTION_10 );//0X0F
    581          
    582            // Call measurement teardown callback
    583            if (battServiceTeardownCB != NULL)
    584            {
    585              battServiceTeardownCB();
    586            }
    587          
    588            if (adc >= battMaxLevel)
    589            {
    590              percent = 100;
    591            }
    592            else if (adc <= battMinLevel)
    593            {
    594              percent = 0;
    595            }
    596            else
    597            {
    598              if (battServiceCalcCB != NULL)
    599              {
    600                percent = battServiceCalcCB(adc);
    601              }
    602              else
    603              {
    604                uint16 range =  battMaxLevel - battMinLevel + 1;
    605          
    606                // optional if you want to keep it even, otherwise just take floor of divide
    607                // range += (range & 1);
    608                range >>= 2; // divide by 4
    609          
    610                percent = (uint8) ((((adc - battMinLevel) * 25) + (range - 1)) / range);
    611              }
    612            }
    613          
    614            return percent;
    615          }
    616          
    617          /*********************************************************************
    618           * @fn      battNotifyLevelState
    619           *
    620           * @brief   Send a notification of the battery level state
    621           *          characteristic if a connection is established.
    622           *
    623           * @return  None.
    624           */
    625          static void battNotifyLevel( void )
    626          {
    627            // Execute linkDB callback to send notification
    628            linkDB_PerformFunc( battNotifyCB );
    629          }
    630          
    631          /*********************************************************************
    632           * @fn          Batt_HandleConnStatusCB
    633           *
    634           * @brief       Battery Service link status change handler function.
    635           *
    636           * @param       connHandle - connection handle
    637           * @param       changeType - type of change
    638           *
    639           * @return      none
    640           */
    641          void Batt_HandleConnStatusCB( uint16 connHandle, uint8 changeType )
    642          {
    643            // Make sure this is not loopback connection
    644            if ( connHandle != LOOPBACK_CONNHANDLE )
    645            {
    646              // Reset Client Char Config if connection has dropped
    647              if ( ( changeType == LINKDB_STATUS_UPDATE_REMOVED )      ||
    648                   ( ( changeType == LINKDB_STATUS_UPDATE_STATEFLAGS ) &&
    649                     ( !linkDB_Up( connHandle ) ) ) )
    650              {
    651                GATTServApp_InitCharCfg( connHandle, battLevelClientCharCfg );
    652              }
    653            }
    654          }
    655          
    656          
    657          /*********************************************************************
    658          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     12  Batt_AddService
                          0 0 10 -> GATTServApp_InitCharCfg
                          0 0 12 -> GATTServApp_RegisterService
       1      0      9  Batt_GetParameter
       0      0      9  Batt_HandleConnStatusCB
                          0 0  9 -> GATTServApp_InitCharCfg
                          0 0  9 -> linkDB_State
       0      0     11  Batt_MeasLevel
                          0 0 10 -> HalLcdWriteString
                          0 0 11 -> HalLcdWriteStringValue
                          0 0 10 -> battMeasure
                          0 0 10 -> linkDB_PerformFunc
       2      0      0  Batt_Register
       0      0      9  Batt_SetParameter
                          0 0  9 -> linkDB_PerformFunc
       0      0     18  Batt_Setup
       2      0     21  battMeasure
                          0 0 10 -> HalAdcRead
                          0 0 10 -> HalAdcSetReference
       1      0     32  battNotifyCB
                          0 0 32 -> GATTServApp_ReadCharCfg
                          0 0 32 -> GATT_Notification
       1      0     19  battReadAttrCB
                          0 0 11 -> battMeasure
                          0 0 13 -> osal_memcpy
       0      0     24  battWriteAttrCB
                          0 0 20 -> GATTServApp_ProcessCCCWriteReq


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "batt_lebel:">
      18  ?<Constant "now  start batt..">
      40  ?<Initializer for battAttrTbl>
       1  ?<Initializer for battLevel>
       1  ?<Initializer for battLevelProps>
       2  ?<Initializer for battMaxLevel>
       2  ?<Initializer for battMinLevel>
       1  ?<Initializer for battServiceAdcCh>
       2  ?<Initializer for hidReportRefBattLevel>
       6  ??Batt_AddService?relay
       6  ??Batt_GetParameter?relay
       6  ??Batt_HandleConnStatusCB?relay
       6  ??Batt_MeasLevel?relay
       6  ??Batt_Register?relay
       6  ??Batt_SetParameter?relay
       6  ??Batt_Setup?relay
       5  ??Subroutine10_0
       4  ??Subroutine9_0
       6  ??battMeasure?relay
       6  ??battNotifyCB?relay
       6  ??battReadAttrCB?relay
       6  ??battWriteAttrCB?relay
       5  ?Subroutine0
       1  ?Subroutine1
       6  ?Subroutine2
      12  ?Subroutine3
      14  ?Subroutine4
       3  ?Subroutine5
      10  ?Subroutine6
       6  ?Subroutine7
       6  ?Subroutine8
      43  Batt_AddService
     104  Batt_GetParameter
      55  Batt_HandleConnStatusCB
      71  Batt_MeasLevel
      19  Batt_Register
      47  Batt_SetParameter
      97  Batt_Setup
      40  battAttrTbl
       6  battCBs
       1  battCriticalLevel
       1  battLevel
       6  battLevelClientCharCfg
       1  battLevelProps
       2  battLevelUUID
       2  battMaxLevel
     193  battMeasure
       2  battMinLevel
     118  battNotifyCB
     171  battReadAttrCB
       2  battServUUID
       3  battService
       1  battServiceAdcCh
       2  battServiceCB
       2  battServiceCalcCB
       2  battServiceSetupCB
       2  battServiceTeardownCB
     135  battWriteAttrCB
       2  hidReportRefBattLevel

 
 1 125 bytes in segment BANKED_CODE
    66 bytes in segment BANK_RELAYS
    49 bytes in segment XDATA_I
    49 bytes in segment XDATA_ID
    43 bytes in segment XDATA_ROM_C
    15 bytes in segment XDATA_Z
 
 1 240 bytes of CODE  memory
    43 bytes of CONST memory
    64 bytes of XDATA memory

Errors: none
Warnings: 1
