###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             11/Mar/2014  11:30:12 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          Profiles\Roles\gapbondmgr.c                        #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralz\CC2541DB\..\..\config\buil #
#                          dComponents.cfg (-DBROADCASTER_CFG=0x01            #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheralz\CC2541DB\buildConfi #
#                          g.cfg (-DHOST_CONFIG=PERIPHERAL_CFG                #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          Profiles\Roles\gapbondmgr.c -D INT_HEAP_LEN=3074   #
#                          -D HALNODEBUG -D OSAL_CBTIMER_NUM_TASKS=1 -D       #
#                          xHAL_AES_DMA=TRUE -D HAL_DMA=TRUE -D POWER_SAVING  #
#                          -D xPLUS_BROADCASTER -D HAL_LCD=TRUE -D            #
#                          HAL_LED=TRUE -D HAL_UART=TRUE -D HAL_ADC=TRUE      #
#                          -lcN E:\TexasInstruments\BLE-CC254x-1.4.0\Projects #
#                          \ble\SimpleBLEPeripheralz\CC2541DB\CC2541\List\    #
#                          -o E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralz\CC2541DB\CC2541\Obj\ -e    #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralz\CC2541DB\..\..\common\ -I  #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\include\ -I    #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\..\..\Componen #
#                          ts\hal\include\ -I E:\TexasInstruments\BLE-CC254x- #
#                          1.4.0\Projects\ble\SimpleBLEPeripheralz\CC2541DB\. #
#                          .\..\..\..\Components\hal\target\CC2541EB\ -I      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\..\..\Componen #
#                          ts\osal\include\ -I E:\TexasInstruments\BLE-CC254x #
#                          -1.4.0\Projects\ble\SimpleBLEPeripheralz\CC2541DB\ #
#                          ..\..\..\..\Components\services\saddr\ -I          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\..\..\Componen #
#                          ts\ble\include\ -I E:\TexasInstruments\BLE-CC254x- #
#                          1.4.0\Projects\ble\SimpleBLEPeripheralz\CC2541DB\. #
#                          .\..\..\..\Components\ble\controller\phy\ -I       #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\..\..\Componen #
#                          ts\ble\controller\include\ -I                      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\..\..\Componen #
#                          ts\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1.4. #
#                          0\Projects\ble\SimpleBLEPeripheralz\CC2541DB\..\.. #
#                          \..\..\Components\ble\host\ -I                     #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\common\cc2540\ #
#                           -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralz\CC2541DB\..\..\common\npi #
#                          \npi_np\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\P #
#                          rojects\ble\SimpleBLEPeripheralz\CC2541DB\..\..\Pr #
#                          ofiles\Roles\ -I E:\TexasInstruments\BLE-CC254x-1. #
#                          4.0\Projects\ble\SimpleBLEPeripheralz\CC2541DB\..\ #
#                          ..\Profiles\SimpleProfile\ -I                      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\..\..\Profiles\DevIn #
#                          fo\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralz\CC2541DB\..\..\Profile #
#                          s\Batt\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Pr #
#                          ojects\ble\SimpleBLEPeripheralz\CC2541DB\..\..\Pro #
#                          files\HIDDev\ -Ohz                                 #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\CC2541\List\gapbondm #
#                          gr.lst                                             #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralz\CC2541DB\CC2541\Obj\gapbondmg #
#                          r.r51                                              #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\Profiles\Roles\gapbondmgr.c
      1          /**************************************************************************************************
      2            Filename:       gapbondmgr.c
      3            Revised:        $Date: 2011-02-24 15:46:53 -0800 (Thu, 24 Feb 2011) $
      4            Revision:       $Revision: 10 $
      5          
      6            Description:    GAP peripheral profile manages bonded connections
      7          
      8          
      9            Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #if ( HOST_CONFIG & ( CENTRAL_CFG | PERIPHERAL_CFG ) )
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          #include "bcomdef.h"
     46          #include "OSAL.h"
     47          #include "osal_snv.h"
     48          #include "gap.h"
     49          #include "linkdb.h"
     50          #include "gatt.h"
     51          #include "gatt_uuid.h"
     52          #include "hci.h"
     53          #include "gattservapp.h"
     54          #include "gapgattserver.h"
     55          #include "gapbondmgr.h"
     56          
     57          /*********************************************************************
     58           * MACROS
     59           */
     60          
     61          /*********************************************************************
     62           * CONSTANTS
     63           */
     64          // Task event types
     65          #define GAP_BOND_SYNC_CC_EVT                            0x0001 // Sync char config
     66          #define GAP_BOND_SAVE_REC_EVT                           0x0002 // Save bond record in NV
     67          
     68          // Once NV usage reaches this percentage threshold, NV compaction gets triggered.
     69          #define NV_COMPACT_THRESHOLD                            80
     70          
     71          // Bonded State Flags
     72          #define GAP_BONDED_STATE_AUTHENTICATED                  0x0001
     73          #define GAP_BONDED_STATE_SERVICE_CHANGED                0x0002
     74          
     75          /**
     76           * GAP Bond Manager NV layout
     77           *
     78           * The NV definitions:
     79           *     BLE_NVID_GAP_BOND_START - starting NV ID
     80           *     GAP_BONDINGS_MAX - Maximum number of bonding allowed (10 is max for number of NV IDs allocated in bcomdef.h).
     81           *
     82           * A single bonding entry consists of 6 components (NV items):
     83           *     Bond Record - defined as gapBondRec_t and uses GAP_BOND_REC_ID_OFFSET for an NV ID
     84           *     local LTK Info - defined as gapBondLTK_t and uses GAP_BOND_LOCAL_LTK_OFFSET for an NV ID
     85           *     device LTK Info - defined as gapBondLTK_t and uses GAP_BOND_DEV_LTK_OFFSET for an NV ID
     86           *     device IRK - defined as "uint8 devIRK[KEYLEN]" and uses GAP_BOND_DEV_IRK_OFFSET for an NV ID
     87           *     device CSRK - defined as "uint8 devCSRK[KEYLEN]" and uses GAP_BOND_DEV_CSRK_OFFSET for an NV ID
     88           *     device Sign Counter - defined as a uint32 and uses GAP_BOND_DEV_SIGN_COUNTER_OFFSET for an NV ID
     89           *
     90           * When the device is initialized for the first time, all (GAP_BONDINGS_MAX) NV items are created and
     91           * initialized to all 0xFF's. A bonding record of all 0xFF's indicates that the bonding record is empty
     92           * and free to use.
     93           *
     94           * The calculation for each bonding records NV IDs:
     95           *    mainRecordNvID = ((bondIdx * GAP_BOND_REC_IDS) + BLE_NVID_GAP_BOND_START)
     96           *    localLTKNvID = (((bondIdx * GAP_BOND_REC_IDS) + GAP_BOND_LOCAL_LTK_OFFSET) + BLE_NVID_GAP_BOND_START)
     97           *
     98           */
     99          #define GAP_BOND_REC_ID_OFFSET              0 //!< NV ID for the main bonding record
    100          #define GAP_BOND_LOCAL_LTK_OFFSET           1 //!< NV ID for the bonding record's local LTK information
    101          #define GAP_BOND_DEV_LTK_OFFSET             2 //!< NV ID for the bonding records' device LTK information
    102          #define GAP_BOND_DEV_IRK_OFFSET             3 //!< NV ID for the bonding records' device IRK
    103          #define GAP_BOND_DEV_CSRK_OFFSET            4 //!< NV ID for the bonding records' device CSRK
    104          #define GAP_BOND_DEV_SIGN_COUNTER_OFFSET    5 //!< NV ID for the bonding records' device Sign Counter
    105          
    106          #define GAP_BOND_REC_IDS                    6
    107          
    108          // Macros to calculate the index/offset in to NV space
    109          #define calcNvID(Idx, offset)               (((((Idx) * GAP_BOND_REC_IDS) + (offset))) + BLE_NVID_GAP_BOND_START)
    110          #define mainRecordNvID(bondIdx)             (calcNvID((bondIdx), GAP_BOND_REC_ID_OFFSET))
    111          #define localLTKNvID(bondIdx)               (calcNvID((bondIdx), GAP_BOND_LOCAL_LTK_OFFSET))
    112          #define devLTKNvID(bondIdx)                 (calcNvID((bondIdx), GAP_BOND_DEV_LTK_OFFSET))
    113          #define devIRKNvID(bondIdx)                 (calcNvID((bondIdx), GAP_BOND_DEV_IRK_OFFSET))
    114          #define devCSRKNvID(bondIdx)                (calcNvID((bondIdx), GAP_BOND_DEV_CSRK_OFFSET))
    115          #define devSignCounterNvID(bondIdx)         (calcNvID((bondIdx), GAP_BOND_DEV_SIGN_COUNTER_OFFSET))
    116          
    117          // Macros to calculate the GATT index/offset in to NV space
    118          #define gattCfgNvID(Idx)                    ((Idx) + BLE_NVID_GATT_CFG_START)
    119          
    120          // Key Size Limits
    121          #define MIN_ENC_KEYSIZE                     7  //!< Minimum number of bytes for the encryption key
    122          #define MAX_ENC_KEYSIZE                     16 //!< Maximum number of bytes for the encryption key
    123          
    124          /*********************************************************************
    125           * TYPEDEFS
    126           */
    127          
    128          // Structure of NV data for the connected device's encryption information
    129          typedef struct
    130          {
    131            uint8   LTK[KEYLEN];              // Long Term Key (LTK)
    132            uint16  div;  //lint -e754        // LTK eDiv
    133            uint8   rand[B_RANDOM_NUM_SIZE];  // LTK random number
    134            uint8   keySize;                  // LTK key size
    135          } gapBondLTK_t;
    136          
    137          // Structure of NV data for the connected device's address information
    138          typedef struct
    139          {
    140            uint8   publicAddr[B_ADDR_LEN];     // Master's address
    141            uint8   reconnectAddr[B_ADDR_LEN];  // Privacy Reconnection Address
    142            uint16  stateFlags;                 // State flags: SM_AUTH_STATE_AUTHENTICATED & SM_AUTH_STATE_BONDING
    143          } gapBondRec_t;
    144          
    145          // Structure of NV data for the connected device's characteristic configuration
    146          typedef struct
    147          {
    148            uint16 attrHandle;  // attribute handle
    149            uint8  value;       // attribute value for this device
    150          } gapBondCharCfg_t;
    151          
    152          /*********************************************************************
    153           * GLOBAL VARIABLES
    154           */
    155          
    156          /*********************************************************************
    157           * EXTERNAL VARIABLES
    158           */
    159          
    160          /*********************************************************************
    161           * EXTERNAL FUNCTIONS
    162           */
    163          
    164          /*********************************************************************
    165           * LOCAL VARIABLES
    166           */
    167          static uint8 gapBondMgr_TaskID;   // Task ID for internal task/event processing
    168          
    169          // GAPBonding Parameters
    170          static uint8 gapBond_PairingMode = GAPBOND_PAIRING_MODE_WAIT_FOR_REQ;
    171          static uint16 gapBond_InitiateWait = 1000;  // Default to 1 second
    172          static uint8 gapBond_MITM = FALSE;
    173          static uint8 gapBond_IOCap = GAPBOND_IO_CAP_DISPLAY_ONLY;
    174          static uint8 gapBond_OOBDataFlag = FALSE;
    175          static uint8 gapBond_OOBData[KEYLEN] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    176          static uint8 gapBond_Bonding = FALSE;
    177          static uint8 gapBond_AutoFail = FALSE;
    178          static uint8 gapBond_AutoFailReason = SMP_PAIRING_FAILED_NOT_SUPPORTED;
    179          static uint8 gapBond_KeyDistList =
    180          (
    181            GAPBOND_KEYDIST_SENCKEY     // sEncKey enabled, to send the encryption key
    182             | GAPBOND_KEYDIST_SIDKEY   // sIdKey enabled, to send the IRK, and BD_ADDR
    183             | GAPBOND_KEYDIST_SSIGN    // sSign enabled, to send the CSRK
    184             | GAPBOND_KEYDIST_MENCKEY  // mEncKey enabled, to get the master's encryption key
    185             | GAPBOND_KEYDIST_MIDKEY   // mIdKey enabled, to get the master's IRK and BD_ADDR
    186             | GAPBOND_KEYDIST_MSIGN    // mSign enabled, to get the master's CSRK
    187          );
    188          static uint32 gapBond_Passcode = 0;
    189          static uint8  gapBond_KeySize = MAX_ENC_KEYSIZE;
    190          
    191          #if ( HOST_CONFIG & CENTRAL_CFG )
    192          static uint8  gapBond_BondFailOption = GAPBOND_FAIL_TERMINATE_LINK;
    193          #endif
    194          
    195          static const gapBondCBs_t *pGapBondCB = NULL;
    196          
    197          // Local RAM shadowed bond records
    198          static gapBondRec_t bonds[GAP_BONDINGS_MAX] = {0};
    199          
    200          static uint8 autoSyncWhiteList = FALSE;
    201          
    202          static uint8 eraseAllBonds = FALSE;
    203          
    204          static uint8 bondsToDelete[GAP_BONDINGS_MAX] = {FALSE};
    205          
    206          // Globals used for saving bond record and CCC values in NV
    207          static uint8 bondIdx = GAP_BONDINGS_MAX;
    208          static gapAuthCompleteEvent_t *pAuthEvt = NULL;
    209          
    210          /*********************************************************************
    211           * LOCAL FUNCTIONS
    212           */
    213          static uint8 gapBondMgrChangeState( uint8 idx, uint16 state, uint8 set );
    214          static uint8 gapBondMgrUpdateCharCfg( uint8 idx, uint16 attrHandle, uint16 value );
    215          static gapBondCharCfg_t *gapBondMgrFindCharCfgItem( uint16 attrHandle,
    216                                                              gapBondCharCfg_t *charCfgTbl );
    217          static void gapBondMgrInvertCharCfgItem( gapBondCharCfg_t *charCfgTbl );
    218          static uint8 gapBondMgrAddBond( gapBondRec_t *pBondRec, gapAuthCompleteEvent_t *pPkt );
    219          static uint8 gapBondMgrGetStateFlags( uint8 idx );
    220          static bStatus_t gapBondMgrGetPublicAddr( uint8 idx, uint8 *pAddr );
    221          static uint8 gapBondMgrFindReconnectAddr( uint8 *pReconnectAddr );
    222          static uint8 gapBondMgrFindAddr( uint8 *pDevAddr );
    223          static uint8 gapBondMgrResolvePrivateAddr( uint8 *pAddr );
    224          static void gapBondMgrReadBonds( void );
    225          static uint8 gapBondMgrFindEmpty( void );
    226          static uint8 gapBondMgrBondTotal( void );
    227          static bStatus_t gapBondMgrEraseAllBondings( void );
    228          static bStatus_t gapBondMgrEraseBonding( uint8 idx );
    229          static uint8 gapBondMgr_ProcessOSALMsg( osal_event_hdr_t *pMsg );
    230          static void gapBondMgrSendServiceChange( linkDBItem_t *pLinkItem );
    231          static void gapBondMgr_ProcessGATTMsg( gattMsgEvent_t *pMsg );
    232          static void gapBondMgr_ProcessGATTServMsg( gattEventHdr_t *pMsg );
    233          static void gapBondSetupPrivFlag( void );
    234          static void gapBondMgrBondReq( uint16 connHandle, uint8 idx, uint8 stateFlags,
    235                                         uint8 role, uint8 startEncryption );
    236          static void gapBondMgrAuthenticate( uint16 connHandle, uint8 addrType,
    237                                              gapPairingReq_t *pPairReq );
    238          static void gapBondMgr_SyncWhiteList( void );
    239          static uint8 gapBondMgr_SyncCharCfg( uint16 connHandle );
    240          static void gapBondFreeAuthEvt( void );
    241          
    242          #if ( HOST_CONFIG & PERIPHERAL_CFG )
    243          static void gapBondMgrSlaveSecurityReq( uint16 connHandle );
    244          #endif
    245          
    246          /*********************************************************************
    247           * NETWORK LAYER CALLBACKS
    248           */
    249          
    250          /*********************************************************************
    251           * PUBLIC FUNCTIONS
    252           */
    253          
    254          /*********************************************************************
    255           * @brief   Set a GAP Bond Manager parameter.
    256           *
    257           * Public function defined in gapbondmgr.h.
    258           */
    259          bStatus_t GAPBondMgr_SetParameter( uint16 param, uint8 len, void *pValue )
    260          {
    261            bStatus_t ret = SUCCESS;  // return value
    262          
    263            switch ( param )
    264            {
    265              case GAPBOND_PAIRING_MODE:
    266                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_PAIRING_MODE_INITIATE) )
    267                {
    268                  gapBond_PairingMode = *((uint8*)pValue);
    269                }
    270                else
    271                {
    272                  ret = bleInvalidRange;
    273                }
    274                break;
    275          
    276              case GAPBOND_INITIATE_WAIT:
    277                if ( len == sizeof ( uint16 ) )
    278                {
    279                  gapBond_InitiateWait = *((uint16*)pValue);
    280                }
    281                else
    282                {
    283                  ret = bleInvalidRange;
    284                }
    285                break;
    286          
    287              case GAPBOND_MITM_PROTECTION:
    288                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
    289                {
    290                  gapBond_MITM = *((uint8*)pValue);
    291                }
    292                else
    293                {
    294                  ret = bleInvalidRange;
    295                }
    296                break;
    297          
    298              case GAPBOND_IO_CAPABILITIES:
    299                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_IO_CAP_KEYBOARD_DISPLAY) )
    300                {
    301                  gapBond_IOCap = *((uint8*)pValue);
    302                }
    303                else
    304                {
    305                  ret = bleInvalidRange;
    306                }
    307                break;
    308          
    309              case GAPBOND_OOB_ENABLED:
    310                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
    311                {
    312                  gapBond_OOBDataFlag = *((uint8*)pValue);
    313                }
    314                else
    315                {
    316                  ret = bleInvalidRange;
    317                }
    318                break;
    319          
    320              case GAPBOND_OOB_DATA:
    321                if ( len == KEYLEN )
    322                {
    323                  VOID osal_memcpy( gapBond_OOBData, pValue, KEYLEN ) ;
    324                }
    325                else
    326                {
    327                  ret = bleInvalidRange;
    328                }
    329                break;
    330          
    331              case GAPBOND_BONDING_ENABLED:
    332                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
    333                {
    334                  gapBond_Bonding = *((uint8*)pValue);
    335                }
    336                else
    337                {
    338                  ret = bleInvalidRange;
    339                }
    340                break;
    341          
    342              case GAPBOND_KEY_DIST_LIST:
    343                if ( len == sizeof ( uint8 ) )
    344                {
    345                  gapBond_KeyDistList = *((uint8*)pValue);
    346                }
    347                else
    348                {
    349                  ret = bleInvalidRange;
    350                }
    351                break;
    352          
    353              case GAPBOND_DEFAULT_PASSCODE:
    354                if ( (len == sizeof ( uint32 ))
    355                    && (*((uint32*)pValue) <= GAP_PASSCODE_MAX) )
    356                {
    357                  gapBond_Passcode = *((uint32*)pValue);
    358                }
    359                else
    360                {
    361                  ret = bleInvalidRange;
    362                }
    363                break;
    364          
    365              case GAPBOND_ERASE_ALLBONDS:
    366                if ( len == 0 )
    367                {
    368                  // Make sure there's no active connection
    369                  if ( GAP_NumActiveConnections() == 0 )
    370                  {
    371                    // Erase all bonding records
    372                    VOID gapBondMgrEraseAllBondings();
    373          
    374                    // See if NV needs a compaction
    375                    VOID osal_snv_compact( NV_COMPACT_THRESHOLD );
    376          
    377                    // Make sure Bond RAM Shadow is up-to-date
    378                    gapBondMgrReadBonds();
    379                  }
    380                  else
    381                  {
    382                    eraseAllBonds = TRUE;
    383                  }
    384                }
    385                else
    386                {
    387                  ret = bleInvalidRange;
    388                }
    389                break;
    390          
    391              case GAPBOND_ERASE_SINGLEBOND:
    392                if ( len == (1 + B_ADDR_LEN) )
    393                {
    394                  uint8 idx;
    395                  uint8 devAddr[B_ADDR_LEN];
    396          
    397                  // Reverse bytes
    398                  VOID osal_revmemcpy( devAddr, (uint8 *)pValue+1, B_ADDR_LEN );
    399                  
    400                  // Resolve address and find index
    401                  idx = GAPBondMgr_ResolveAddr( *((uint8 *)pValue), devAddr, NULL );
    402                  if ( idx < GAP_BONDINGS_MAX )
    403                  {
    404                    // Make sure there's no active connection
    405                    if ( GAP_NumActiveConnections() == 0 )
    406                    {
    407                      // Erase bond
    408                      VOID gapBondMgrEraseBonding( idx );
    409                      
    410                      // See if NV needs a compaction
    411                      VOID osal_snv_compact( NV_COMPACT_THRESHOLD );
    412                      
    413                      // Make sure Bond RAM Shadow is up-to-date
    414                      gapBondMgrReadBonds();
    415                    }
    416                    else
    417                    {
    418                      // Mark entry to be deleted when disconnected
    419                      bondsToDelete[idx] = TRUE;
    420                    }
    421                  }
    422                  else
    423                  {
    424                    ret = INVALIDPARAMETER;
    425                  }
    426                }
    427                else
    428                {
    429                  // Parameter is not the correct length
    430                  ret = bleInvalidRange;
    431                }
    432                break;
    433                
    434              case GAPBOND_AUTO_FAIL_PAIRING:
    435                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= TRUE) )
    436                {
    437                  gapBond_AutoFail = *((uint8*)pValue);
    438                }
    439                else
    440                {
    441                  ret = bleInvalidRange;
    442                }
    443                break;
    444          
    445              case GAPBOND_AUTO_FAIL_REASON:
    446                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= SMP_PAIRING_FAILED_REPEATED_ATTEMPTS) )
    447                {
    448                  gapBond_AutoFailReason = *((uint8*)pValue);
    449                }
    450                else
    451                {
    452                  ret = bleInvalidRange;
    453                }
    454                break;
    455          
    456              case GAPBOND_KEYSIZE:
    457                if ( (len == sizeof ( uint8 ))
    458                    && ((*((uint8*)pValue) >= MIN_ENC_KEYSIZE) && (*((uint8*)pValue) <= MAX_ENC_KEYSIZE)) )
    459                {
    460                  gapBond_KeySize = *((uint8*)pValue);
    461                }
    462                else
    463                {
    464                  ret = bleInvalidRange;
    465                }
    466                break;
    467          
    468              case GAPBOND_AUTO_SYNC_WL:
    469                if ( len == sizeof( uint8 ) )
    470                {
    471                  uint8 oldVal = autoSyncWhiteList;
    472          
    473                  autoSyncWhiteList = *((uint8 *)pValue);
    474          
    475                  // only call if parameter changes from FALSE to TRUE
    476                  if ( ( oldVal == FALSE ) && ( autoSyncWhiteList == TRUE ) )
    477                  {
    478                    // make sure bond is updated from NV
    479                    gapBondMgrReadBonds();
    480                  }
    481                }
    482                else
    483                {
    484                  ret = bleInvalidRange;
    485                }
    486                break;
    487          
    488          #if ( HOST_CONFIG & CENTRAL_CFG )
    489              case GAPBOND_BOND_FAIL_ACTION:
    490                if ( (len == sizeof ( uint8 )) && (*((uint8*)pValue) <= GAPBOND_FAIL_TERMINATE_ERASE_BONDS) )
    491                {
    492                  gapBond_BondFailOption = *((uint8*)pValue);
    493                }
    494                else
    495                {
    496                  ret = bleInvalidRange;
    497                }
    498                break;
    499          #endif
    500          
    501              default:
    502                // The param value isn't part of this profile, try the GAP.
    503                if ( (param < TGAP_PARAMID_MAX) && (len == sizeof ( uint16 )) )
    504                {
    505                  ret = GAP_SetParamValue( param, *((uint16*)pValue) );
    506                }
    507                else
    508                {
    509                  ret = INVALIDPARAMETER;
    510                }
    511                break;
    512            }
    513          
    514            return ( ret );
    515          }
    516          
    517          /*********************************************************************
    518           * @brief   Get a GAP Bond Manager parameter.
    519           *
    520           * Public function defined in gapbondmgr.h.
    521           */
    522          bStatus_t GAPBondMgr_GetParameter( uint16 param, void *pValue )
    523          {
    524            bStatus_t ret = SUCCESS;  // return value
    525          
    526            switch ( param )
    527            {
    528              case GAPBOND_PAIRING_MODE:
    529                *((uint8*)pValue) = gapBond_PairingMode;
    530                break;
    531          
    532              case GAPBOND_INITIATE_WAIT:
    533                *((uint16*)pValue) = gapBond_InitiateWait;
    534                break;
    535          
    536              case GAPBOND_MITM_PROTECTION:
    537                *((uint8*)pValue) = gapBond_MITM;
    538                break;
    539          
    540              case GAPBOND_IO_CAPABILITIES:
    541                *((uint8*)pValue) = gapBond_IOCap;
    542                break;
    543          
    544              case GAPBOND_OOB_ENABLED:
    545                *((uint8*)pValue) = gapBond_OOBDataFlag;
    546                break;
    547          
    548              case GAPBOND_OOB_DATA:
    549                VOID osal_memcpy( pValue, gapBond_OOBData, KEYLEN ) ;
    550                break;
    551          
    552              case GAPBOND_BONDING_ENABLED:
    553                *((uint8*)pValue) = gapBond_Bonding;
    554                break;
    555          
    556              case GAPBOND_KEY_DIST_LIST:
    557                *((uint8*)pValue) = gapBond_KeyDistList;
    558                break;
    559          
    560              case GAPBOND_DEFAULT_PASSCODE:
    561                *((uint32*)pValue) = gapBond_Passcode;
    562                break;
    563          
    564              case GAPBOND_AUTO_FAIL_PAIRING:
    565                *((uint8*)pValue) = gapBond_AutoFail;
    566                break;
    567          
    568              case GAPBOND_AUTO_FAIL_REASON:
    569                *((uint8*)pValue) = gapBond_AutoFailReason;
    570                break;
    571          
    572              case GAPBOND_KEYSIZE:
    573                *((uint8*)pValue) = gapBond_KeySize;
    574                break;
    575          
    576              case GAPBOND_AUTO_SYNC_WL:
    577                *((uint8*)pValue) = autoSyncWhiteList;
    578                break;
    579          
    580              case GAPBOND_BOND_COUNT:
    581                *((uint8*)pValue) = gapBondMgrBondTotal();
    582                break;
    583          
    584              default:
    585                // The param value isn't part of this profile, try the GAP.
    586                if ( param < TGAP_PARAMID_MAX )
    587                {
    588                  *((uint16*)pValue) = GAP_GetParamValue( param );
    589                }
    590                else
    591                {
    592                  ret = INVALIDPARAMETER;
    593                }
    594                break;
    595            }
    596          
    597            return ( ret );
    598          }
    599          
    600          /*********************************************************************
    601           * @brief   Notify the Bond Manager that a connection has been made.
    602           *
    603           * Public function defined in gapbondmgr.h.
    604           */
    605          bStatus_t GAPBondMgr_LinkEst( uint8 addrType, uint8 *pDevAddr, uint16 connHandle, uint8 role )
    606          {
    607            uint8 idx;                          // NV Index
    608            uint8 publicAddr[B_ADDR_LEN]        // Place to put the public address
    609                = {0, 0, 0, 0, 0, 0};
    610          
    611            idx = GAPBondMgr_ResolveAddr( addrType, pDevAddr, publicAddr );
    612            if ( idx < GAP_BONDINGS_MAX )
    613            {
    614              uint8 stateFlags = gapBondMgrGetStateFlags( idx );
    615              smSigningInfo_t signingInfo;
    616              gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX]; // Space to read a char cfg record from NV
    617          
    618              // On peripheral, load the key information for the bonding
    619              // On central and initiaiting security, load key to initiate encyption
    620              gapBondMgrBondReq( connHandle, idx, stateFlags, role,
    621                                 ((gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE ) ? TRUE : FALSE) );
    622          
    623              // Load the Signing Key
    624              VOID osal_memset( &signingInfo, 0, sizeof ( smSigningInfo_t ) );
    625              if ( osal_snv_read( devCSRKNvID(idx), KEYLEN, signingInfo.srk ) == SUCCESS )
    626              {
    627                if ( osal_isbufset( signingInfo.srk, 0xFF, KEYLEN ) == FALSE )
    628                {
    629                  // Load the signing information for this connection
    630                  VOID osal_snv_read( devSignCounterNvID(idx), sizeof ( uint32 ), &(signingInfo.signCounter) );
    631                  VOID GAP_Signable( connHandle,
    632                                    ((stateFlags & GAP_BONDED_STATE_AUTHENTICATED) ? TRUE : FALSE),
    633                                    &signingInfo );
    634                }
    635              }
    636          
    637              // Load the characteristic configuration
    638              if ( osal_snv_read( gattCfgNvID(idx), sizeof ( charCfg ), charCfg ) == SUCCESS )
    639              {
    640                gapBondMgrInvertCharCfgItem( charCfg );
    641          
    642                for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
    643                {
    644                  gapBondCharCfg_t *pItem = &(charCfg[i]);
    645          
    646                  // Apply the characteristic configuration for this connection
    647                  if ( pItem->attrHandle != GATT_INVALID_HANDLE )
    648                  {
    649                    VOID GATTServApp_UpdateCharCfg( connHandle, pItem->attrHandle,
    650                                                    (uint16)(pItem->value) );
    651                  }
    652                }
    653              }
    654          
    655              // Has there been a service change?
    656              if ( stateFlags & GAP_BONDED_STATE_SERVICE_CHANGED )
    657              {
    658                VOID GATTServApp_SendServiceChangedInd( connHandle, gapBondMgr_TaskID );
    659              }
    660            }
    661          #if ( HOST_CONFIG & CENTRAL_CFG )
    662            else if ( role == GAP_PROFILE_CENTRAL &&
    663                      gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE )
    664            {
    665              // If Central and initiating and not bonded, then initiate pairing
    666              gapBondMgrAuthenticate( connHandle, addrType, NULL );
    667          
    668              // Call app state callback
    669              if ( pGapBondCB && pGapBondCB->pairStateCB )
    670              {
    671                pGapBondCB->pairStateCB( connHandle, GAPBOND_PAIRING_STATE_STARTED, SUCCESS );
    672              }
    673            }
    674          #endif
    675          
    676          #if ( HOST_CONFIG & PERIPHERAL_CFG )
    677            // If Peripheral and initiating, send a slave security request to
    678            // initiate either pairing or encryption
    679            if ( role == GAP_PROFILE_PERIPHERAL &&
    680                 gapBond_PairingMode == GAPBOND_PAIRING_MODE_INITIATE )
    681            {
    682              gapBondMgrSlaveSecurityReq( connHandle );
    683            }
    684          #endif
    685          
    686            return ( SUCCESS );
    687          }
    688          
    689          /*********************************************************************
    690           * @brief   Resolve an address from bonding information.
    691           *
    692           * Public function defined in gapbondmgr.h.
    693           */
    694          uint8 GAPBondMgr_ResolveAddr( uint8 addrType, uint8 *pDevAddr, uint8 *pResolvedAddr )
    695          {
    696            uint8 idx = GAP_BONDINGS_MAX;
    697          
    698            switch ( addrType )
    699            {
    700              case ADDRTYPE_PUBLIC:
    701              case ADDRTYPE_STATIC:
    702                idx = gapBondMgrFindAddr( pDevAddr );
    703                if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
    704                {
    705                  VOID osal_memcpy( pResolvedAddr, pDevAddr, B_ADDR_LEN );
    706                }
    707                break;
    708          
    709              case ADDRTYPE_PRIVATE_NONRESOLVE:
    710                // This could be a reconnection address
    711                idx = gapBondMgrFindReconnectAddr( pDevAddr );
    712                if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
    713                {
    714                  VOID gapBondMgrGetPublicAddr( idx, pResolvedAddr );
    715                }
    716                break;
    717          
    718              case ADDRTYPE_PRIVATE_RESOLVE:
    719                // Master's don't use Private Resolvable addresses but just in case
    720                idx = gapBondMgrResolvePrivateAddr( pDevAddr );
    721                if ( (idx < GAP_BONDINGS_MAX) && (pResolvedAddr) )
    722                {
    723                  VOID gapBondMgrGetPublicAddr( idx, pResolvedAddr );
    724                }
    725                break;
    726          
    727              default:
    728                break;
    729            }
    730          
    731            return ( idx );
    732          }
    733          
    734          /*********************************************************************
    735           * @brief   Set/clear the service change indication in a bond record.
    736           *
    737           * Public function defined in gapbondmgr.h.
    738           */
    739          bStatus_t GAPBondMgr_ServiceChangeInd( uint16 connectionHandle, uint8 setParam )
    740          {
    741            bStatus_t ret = bleNoResources; // return value
    742          
    743            if ( connectionHandle == 0xFFFF )
    744            {
    745              uint8 idx;  // loop counter
    746          
    747              // Run through the bond database and update the Service Change indication
    748              for ( idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
    749              {
    750                if ( gapBondMgrChangeState( idx, GAP_BONDED_STATE_SERVICE_CHANGED, setParam ) )
    751                {
    752                  ret = SUCCESS;
    753                }
    754              }
    755          
    756              // If the service change indication is TRUE, tell the connected devices
    757              if ( setParam )
    758              {
    759                // Run connected database
    760                linkDB_PerformFunc( gapBondMgrSendServiceChange );
    761              }
    762            }
    763            else
    764            {
    765              // Find connection information
    766              linkDBItem_t *pLinkItem = linkDB_Find( connectionHandle );
    767              if ( pLinkItem )
    768              {
    769                uint8 idx; // loop counter
    770                idx = GAPBondMgr_ResolveAddr( pLinkItem->addrType, pLinkItem->addr, NULL );
    771                if ( idx < GAP_BONDINGS_MAX )
    772                {
    773                  // Bond found, update it.
    774                  VOID gapBondMgrChangeState( idx, GAP_BONDED_STATE_SERVICE_CHANGED, setParam );
    775                  ret = SUCCESS;
    776                }
    777          
    778                // If the service change indication is TRUE, tell the connected device
    779                if ( setParam )
    780                {
    781                  gapBondMgrSendServiceChange( pLinkItem );
    782                }
    783              }
    784              else
    785              {
    786                ret = bleNotConnected;
    787              }
    788            }
    789          
    790            return ( ret );
    791          }
    792          
    793          /*********************************************************************
    794           * @brief   Update the Characteristic Configuration in a bond record.
    795           *
    796           * Public function defined in gapbondmgr.h.
    797           */
    798          bStatus_t GAPBondMgr_UpdateCharCfg( uint16 connectionHandle, uint16 attrHandle, uint16 value )
    799          {
    800            bStatus_t ret = bleNoResources; // return value
    801          
    802            if ( connectionHandle == INVALID_CONNHANDLE )
    803            {
    804              uint8 idx;  // loop counter
    805          
    806              // Run through the bond database and update the Characteristic Configuration
    807              for ( idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
    808              {
    809                if ( gapBondMgrUpdateCharCfg( idx, attrHandle, value ) )
    810                {
    811                  ret = SUCCESS;
    812                }
    813              }
    814            }
    815            else
    816            {
    817              // Find connection information
    818              linkDBItem_t *pLinkItem = linkDB_Find( connectionHandle );
    819              if ( pLinkItem )
    820              {
    821                uint8 idx = GAPBondMgr_ResolveAddr( pLinkItem->addrType, pLinkItem->addr, NULL );
    822                if ( idx < GAP_BONDINGS_MAX )
    823                {
    824                  // Bond found, update it.
    825                  VOID gapBondMgrUpdateCharCfg( idx, attrHandle, value );
    826                  ret = SUCCESS;
    827                }
    828              }
    829              else
    830              {
    831                ret = bleNotConnected;
    832              }
    833            }
    834          
    835            return ( ret );
    836          }
    837          
    838          /*********************************************************************
    839           * @brief   Register callback functions with the bond manager.
    840           *
    841           * Public function defined in gapbondmgr.h.
    842           */
    843          void GAPBondMgr_Register( gapBondCBs_t *pCB )
    844          {
    845            pGapBondCB = pCB;
    846          
    847            // Take over the processing of Authentication messages
    848            VOID GAP_SetParamValue( TGAP_AUTH_TASK_ID, gapBondMgr_TaskID );
    849          
    850            // Register with GATT Server App for event messages
    851            GATTServApp_RegisterForMsg( gapBondMgr_TaskID );
    852          }
    853          
    854          /*********************************************************************
    855           * @brief   Respond to a passcode request.
    856           *
    857           * Public function defined in gapbondmgr.h.
    858           */
    859          bStatus_t GAPBondMgr_PasscodeRsp( uint16 connectionHandle, uint8 status, uint32 passcode )
    860          {
    861            bStatus_t ret = SUCCESS;
    862          
    863            if ( status == SUCCESS )
    864            {
    865              // Truncate the passcode
    866              passcode = passcode % (GAP_PASSCODE_MAX + 1);
    867          
    868              ret = GAP_PasscodeUpdate( passcode, connectionHandle );
    869              if ( ret != SUCCESS )
    870              {
    871                VOID GAP_TerminateAuth( connectionHandle, SMP_PAIRING_FAILED_PASSKEY_ENTRY_FAILED );
    872              }
    873            }
    874            else
    875            {
    876              VOID GAP_TerminateAuth( connectionHandle, status );
    877            }
    878          
    879            return ret;
    880          }
    881          
    882          /*********************************************************************
    883           * @brief   This is a bypass mechanism to allow the bond manager to process
    884           *              GAP messages.
    885           *
    886           * Public function defined in gapbondmgr.h.
    887           */
    888          uint8 GAPBondMgr_ProcessGAPMsg( gapEventHdr_t *pMsg )
    889          {
    890            switch ( pMsg->opcode )
    891            {
    892              case GAP_PASSKEY_NEEDED_EVENT:
    893                {
    894                  gapPasskeyNeededEvent_t *pPkt = (gapPasskeyNeededEvent_t *)pMsg;
    895          
    896                  if ( pGapBondCB && pGapBondCB->passcodeCB )
    897                  {
    898                    // Ask app for a passcode
    899                    pGapBondCB->passcodeCB( pPkt->deviceAddr, pPkt->connectionHandle, pPkt->uiInputs, pPkt->uiOutputs );
    900                  }
    901                  else
    902                  {
    903                    // No app support, use the default passcode
    904                    if ( GAP_PasscodeUpdate( gapBond_Passcode, pPkt->connectionHandle ) != SUCCESS )
    905                    {
    906                      VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_PASSKEY_ENTRY_FAILED );
    907                    }
    908                  }
    909                }
    910                break;
    911          
    912              case GAP_AUTHENTICATION_COMPLETE_EVENT:
    913                {
    914                  gapAuthCompleteEvent_t *pPkt = (gapAuthCompleteEvent_t *)pMsg;
    915          
    916                  // Should we save bonding information (one save at a time)
    917                  if ( (pPkt->hdr.status == SUCCESS)             && 
    918                       (pPkt->authState & SM_AUTH_STATE_BONDING) &&
    919                       (pAuthEvt == NULL) )
    920                  {
    921                    gapBondRec_t bondRec;
    922          
    923                    VOID osal_memset( &bondRec, 0, sizeof ( gapBondRec_t ) ) ;
    924          
    925                    // Do we have a public address in the data?
    926                    if ( pPkt->pIdentityInfo )
    927                    {
    928                      VOID osal_memcpy( bondRec.publicAddr, pPkt->pIdentityInfo->bd_addr, B_ADDR_LEN );
    929                    }
    930                    else
    931                    {
    932                      linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
    933                      if ( pLinkItem )
    934                      {
    935                        VOID osal_memcpy( bondRec.publicAddr, pLinkItem->addr, B_ADDR_LEN );
    936                      }
    937                      else
    938                      {
    939                        // We don't have an address, so ignore the message.
    940                        break;
    941                      }
    942                    }
    943          
    944                    // Save off of the authentication state
    945                    bondRec.stateFlags |= (pPkt->authState & SM_AUTH_STATE_AUTHENTICATED) ? GAP_BONDED_STATE_AUTHENTICATED : 0;
    946          
    947                    if ( !gapBondMgrAddBond( &bondRec, pPkt ) )
    948                    {
    949                      // Notify our task to save bonding information in NV
    950                      osal_set_event( gapBondMgr_TaskID, GAP_BOND_SAVE_REC_EVT );
    951                
    952                      // We're not done with this message; it will be freed later
    953                      return ( FALSE );
    954                    }
    955                  }
    956          
    957                  // Call app state callback in the fail case. Success is handled after GAP_BOND_SAVE_REC_EVT.
    958                  if ( pGapBondCB && pGapBondCB->pairStateCB )
    959                  {
    960                    pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_COMPLETE, pPkt->hdr.status );
    961                  }
    962                }
    963                break;
    964          
    965              case GAP_BOND_COMPLETE_EVENT:
    966                // This message is received when the bonding is complete.  If hdr.status is SUCCESS
    967                // then call app state callback.  If hdr.status is NOT SUCCESS, the connection will be
    968                // dropped at the LL because of a MIC failure, so again nothing to do.
    969                {
    970                  gapBondCompleteEvent_t *pPkt = (gapBondCompleteEvent_t *)pMsg;
    971          
    972          #if ( HOST_CONFIG & CENTRAL_CFG )
    973                  if ( pPkt->hdr.status == LL_ENC_KEY_REQ_REJECTED )
    974                  {
    975                    // LTK not found on peripheral device (Pin or Key Missing). See which
    976                    // option was configured for unsuccessful bonding.
    977                    linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
    978                    if ( pLinkItem )
    979                    {
    980                      switch ( gapBond_BondFailOption )
    981                      {
    982                        case GAPBOND_FAIL_INITIATE_PAIRING:
    983                          // Initiate pairing
    984                          gapBondMgrAuthenticate( pPkt->connectionHandle, pLinkItem->addrType, NULL );
    985                          break;
    986          
    987                        case GAPBOND_FAIL_TERMINATE_LINK:
    988                          // Drop connection
    989                          GAP_TerminateLinkReq( pLinkItem->taskID, pPkt->connectionHandle, HCI_DISCONNECT_AUTH_FAILURE );
    990                          break;
    991          
    992                        case GAPBOND_FAIL_TERMINATE_ERASE_BONDS:
    993                          // Set up bond manager to erase all existing bonds after connection terminates
    994                          VOID GAPBondMgr_SetParameter( GAPBOND_ERASE_ALLBONDS, 0, NULL );
    995          
    996                          // Drop connection
    997                          GAP_TerminateLinkReq( pLinkItem->taskID, pPkt->connectionHandle, HCI_DISCONNECT_AUTH_FAILURE );
    998                          break;
    999          
   1000                        case GAPBOND_FAIL_NO_ACTION:
   1001                          // fall through
   1002                        default:
   1003                          // do nothing
   1004                          break;
   1005                      }
   1006                    }
   1007                  }
   1008          #endif
   1009                  if ( pGapBondCB && pGapBondCB->pairStateCB )
   1010                  {
   1011                    pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_BONDED, pMsg->hdr.status );
   1012                  }
   1013                }
   1014                break;
   1015          
   1016              case GAP_SIGNATURE_UPDATED_EVENT:
   1017                {
   1018                  uint8 idx;
   1019                  gapSignUpdateEvent_t *pPkt = (gapSignUpdateEvent_t *)pMsg;
   1020          
   1021                  idx = GAPBondMgr_ResolveAddr( pPkt->addrType, pPkt->devAddr, NULL );
   1022                  if ( idx < GAP_BONDINGS_MAX )
   1023                  {
   1024                    // Save the sign counter
   1025                    VOID osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), &(pPkt->signCounter) );
   1026                  }
   1027                }
   1028                break;
   1029          
   1030          #if ( HOST_CONFIG & PERIPHERAL_CFG )
   1031              case GAP_PAIRING_REQ_EVENT:
   1032                {
   1033                  gapPairingReqEvent_t *pPkt = (gapPairingReqEvent_t *)pMsg;
   1034          
   1035                  if ( gapBond_AutoFail != FALSE )
   1036                  {
   1037                    // Auto Fail TEST MODE (DON'T USE THIS) - Sends pre-setup reason
   1038                    VOID GAP_TerminateAuth( pPkt->connectionHandle, gapBond_AutoFailReason );
   1039                  }
   1040                  else if ( gapBond_PairingMode == GAPBOND_PAIRING_MODE_NO_PAIRING )
   1041                  {
   1042                    // No Pairing - Send error
   1043                    VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_NOT_SUPPORTED );
   1044                  }
   1045                  else
   1046                  {
   1047                    linkDBItem_t *pLinkItem = linkDB_Find( pPkt->connectionHandle );
   1048          
   1049                    // Requesting bonding?
   1050                    if ( pPkt->pairReq.authReq & SM_AUTH_STATE_BONDING )
   1051                    {
   1052                      if ( pLinkItem )
   1053                      {
   1054                        if ( (pLinkItem->addrType != ADDRTYPE_PUBLIC) && (pPkt->pairReq.keyDist.mIdKey == FALSE) )
   1055                        {
   1056                          uint8 publicAddr[B_ADDR_LEN];
   1057          
   1058                          // Check if we already have the public address in NV
   1059                          if ( GAPBondMgr_ResolveAddr(pLinkItem->addrType, pLinkItem->addr, publicAddr ) == FALSE )
   1060                          {
   1061                            // Can't bond to a non-public address if we don't know the public address
   1062                            VOID GAP_TerminateAuth( pPkt->connectionHandle, SMP_PAIRING_FAILED_AUTH_REQ );
   1063                            break;
   1064                          }
   1065                        }
   1066                      }
   1067                      else
   1068                      {
   1069                        // Can't find the connection, ignore the message
   1070                        break;
   1071                      }
   1072                    }
   1073          
   1074                    // Send pairing response
   1075                    gapBondMgrAuthenticate( pPkt->connectionHandle, pLinkItem->addrType, &(pPkt->pairReq) );
   1076          
   1077                    // Call app state callback
   1078                    if ( pGapBondCB && pGapBondCB->pairStateCB )
   1079                    {
   1080                      pGapBondCB->pairStateCB( pPkt->connectionHandle, GAPBOND_PAIRING_STATE_STARTED, SUCCESS );
   1081                    }
   1082                  }
   1083                }
   1084                break;
   1085          #endif
   1086          
   1087          #if ( HOST_CONFIG & CENTRAL_CFG )
   1088              case GAP_SLAVE_REQUESTED_SECURITY_EVENT:
   1089                {
   1090                  uint16 connHandle = ((gapSlaveSecurityReqEvent_t *)pMsg)->connectionHandle;
   1091                  uint8 idx;
   1092                  uint8 publicAddr[B_ADDR_LEN] = {0, 0, 0, 0, 0, 0};
   1093                  linkDBItem_t *pLink = linkDB_Find( connHandle );
   1094          
   1095                  // If link found and not already initiating security
   1096                  if (pLink != NULL && gapBond_PairingMode != GAPBOND_PAIRING_MODE_INITIATE)
   1097                  {
   1098                    // If already bonded initiate encryption
   1099                    idx = GAPBondMgr_ResolveAddr( pLink->addrType, pLink->addr, publicAddr );
   1100                    if ( idx < GAP_BONDINGS_MAX )
   1101                    {
   1102                      gapBondMgrBondReq( connHandle, idx, gapBondMgrGetStateFlags( idx ),
   1103                                         GAP_PROFILE_CENTRAL, TRUE );
   1104                    }
   1105                    // Else if no pairing allowed
   1106                    else if ( gapBond_PairingMode == GAPBOND_PAIRING_MODE_NO_PAIRING )
   1107                    {
   1108                      // Send error
   1109                      VOID GAP_TerminateAuth( connHandle, SMP_PAIRING_FAILED_NOT_SUPPORTED );
   1110                    }
   1111                    // Else if waiting for request
   1112                    else if (gapBond_PairingMode == GAPBOND_PAIRING_MODE_WAIT_FOR_REQ)
   1113                    {
   1114                      // Initiate pairing
   1115                      gapBondMgrAuthenticate( connHandle, pLink->addrType, NULL );
   1116                    }
   1117                  }
   1118                }
   1119                break;
   1120          #endif
   1121          
   1122              case GAP_LINK_TERMINATED_EVENT:
   1123                if ( GAP_NumActiveConnections() == 0 )
   1124                {
   1125                  // See if we're asked to erase all bonding records
   1126                  if ( eraseAllBonds == TRUE )
   1127                  {
   1128                    VOID gapBondMgrEraseAllBondings();
   1129                    eraseAllBonds = FALSE;
   1130                    
   1131                    // Reset bonds to delete table
   1132                    osal_memset( bondsToDelete, FALSE, sizeof( bondsToDelete ) );
   1133                  }
   1134                  else
   1135                  {
   1136                    // See if we're asked to erase any single bonding records
   1137                    for (uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++)
   1138                    {
   1139                      if ( bondsToDelete[idx] == TRUE )
   1140                      {
   1141                        VOID gapBondMgrEraseBonding( idx );
   1142                        bondsToDelete[idx] = FALSE;
   1143                      }
   1144                    }
   1145                  }
   1146          
   1147                  // See if NV needs a compaction
   1148                  VOID osal_snv_compact( NV_COMPACT_THRESHOLD );
   1149          
   1150                  // Make sure Bond RAM Shadow is up-to-date
   1151                  gapBondMgrReadBonds();
   1152                }
   1153                break;
   1154          
   1155              default:
   1156                break;
   1157            }
   1158            
   1159            return ( TRUE );
   1160          }
   1161          
   1162          /*********************************************************************
   1163           * LOCAL FUNCTION PROTOTYPES
   1164           */
   1165          
   1166          /*********************************************************************
   1167           * @fn      gapBondMgrChangeState
   1168           *
   1169           * @brief   Change a state flag in the stateFlags field of the bond record.
   1170           *
   1171           * @param   idx - Bond NV index
   1172           * @param   state - state flage to set or clear
   1173           * @param   set - TRUE to set the flag, FALSE to clear the flag
   1174           *
   1175           * @return  TRUE if NV Record exists, FALSE if NV Record is empty
   1176           */
   1177          static uint8 gapBondMgrChangeState( uint8 idx, uint16 state, uint8 set )
   1178          {
   1179            gapBondRec_t bondRec;   // Space to read a Bond record from NV
   1180          
   1181            // Look for public address that is used (not all 0xFF's)
   1182            if ( (osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS)
   1183                && (osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE) )
   1184            {
   1185              // Update the state of the bonded device.
   1186              uint8 stateFlags = bondRec.stateFlags;
   1187              if ( set )
   1188              {
   1189                stateFlags |= state;
   1190              }
   1191              else
   1192              {
   1193                stateFlags &= ~(state);
   1194              }
   1195          
   1196              if ( stateFlags != bondRec.stateFlags )
   1197              {
   1198                bondRec.stateFlags = stateFlags;
   1199                VOID osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
   1200              }
   1201              return ( TRUE );
   1202            }
   1203            return ( FALSE );
   1204          }
   1205          
   1206          /*********************************************************************
   1207           * @fn      gapBondMgrUpdateCharCfg
   1208           *
   1209           * @brief   Update the Characteristic Configuration of the bond record.
   1210           *
   1211           * @param   idx - Bond NV index
   1212           * @param   attrHandle - attribute handle (0 means all handles)
   1213           * @param   value - characteristic configuration value
   1214           *
   1215           * @return  TRUE if NV Record exists, FALSE if NV Record is empty
   1216           */
   1217          static uint8 gapBondMgrUpdateCharCfg( uint8 idx, uint16 attrHandle, uint16 value )
   1218          {
   1219            gapBondRec_t bondRec;   // Space to read a Bond record from NV
   1220          
   1221            // Look for public address that is used (not all 0xFF's)
   1222            if ( ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
   1223                 && ( osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE ) )
   1224            {
   1225              gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX]; // Space to read a char cfg record from NV
   1226          
   1227              if ( osal_snv_read( gattCfgNvID(idx), sizeof ( charCfg ), charCfg ) == SUCCESS )
   1228              {
   1229                uint8 update = FALSE;
   1230          
   1231                gapBondMgrInvertCharCfgItem( charCfg );
   1232          
   1233                if ( attrHandle == GATT_INVALID_HANDLE )
   1234                {
   1235                  if ( osal_isbufset( (uint8 *)charCfg, 0x00, sizeof ( charCfg ) ) == FALSE )
   1236                  {
   1237                    // Clear all characteristic configuration for this device
   1238                    VOID osal_memset( (void *)charCfg, 0x00, sizeof ( charCfg ) );
   1239                    update = TRUE;
   1240                  }
   1241                }
   1242                else
   1243                {
   1244                  gapBondCharCfg_t *pItem = gapBondMgrFindCharCfgItem( attrHandle, charCfg );
   1245                  if ( pItem == NULL )
   1246                  {
   1247                    // Must be a new item; ignore if the value is no operation (default)
   1248                    if ( ( value == GATT_CFG_NO_OPERATION ) ||
   1249                         ( ( pItem = gapBondMgrFindCharCfgItem( GATT_INVALID_HANDLE, charCfg ) ) == NULL ) )
   1250                    {
   1251                      return ( FALSE ); // No empty entry found
   1252                    }
   1253          
   1254                    pItem->attrHandle = attrHandle;
   1255                  }
   1256          
   1257                  if ( pItem->value != value )
   1258                  {
   1259                    // Update characteristic configuration
   1260                    pItem->value = (uint8)value;
   1261                    if ( value == GATT_CFG_NO_OPERATION )
   1262                    {
   1263                      // Erease the item
   1264                      pItem->attrHandle = GATT_INVALID_HANDLE;
   1265                    }
   1266          
   1267                    update = TRUE;
   1268                  }
   1269                }
   1270          
   1271                // Update the characteristic configuration of the bonded device.
   1272                if ( update )
   1273                {
   1274                  gapBondMgrInvertCharCfgItem( charCfg );
   1275                  VOID osal_snv_write( gattCfgNvID(idx), sizeof( charCfg ), charCfg );
   1276                }
   1277              }
   1278          
   1279              return ( TRUE );
   1280            }
   1281          
   1282            return ( FALSE );
   1283          }
   1284          
   1285          /*********************************************************************
   1286           * @fn      gapBondMgrFindCharCfgItem
   1287           *
   1288           * @brief   Find the Characteristic Configuration for a given attribute.
   1289           *          Uses the attribute handle to search the charactersitic
   1290           *          configuration table of a bonded device.
   1291           *
   1292           * @param   attrHandle - attribute handle.
   1293           * @param   charCfgTbl - characteristic configuration table.
   1294           *
   1295           * @return  pointer to the found item. NULL, otherwise.
   1296           */
   1297          static gapBondCharCfg_t *gapBondMgrFindCharCfgItem( uint16 attrHandle,
   1298                                                              gapBondCharCfg_t *charCfgTbl )
   1299          {
   1300            for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
   1301            {
   1302              if ( charCfgTbl[i].attrHandle == attrHandle )
   1303              {
   1304                return ( &(charCfgTbl[i]) );
   1305              }
   1306            }
   1307          
   1308            return ( (gapBondCharCfg_t *)NULL );
   1309          }
   1310          
   1311          /*********************************************************************
   1312           * @fn      gapBondMgrFindCharCfgItem
   1313           *
   1314           * @brief   Invert the Characteristic Configuration for a given client.
   1315           *
   1316           * @param   charCfgTbl - characteristic configuration table.
   1317           *
   1318           * @return  none.
   1319           */
   1320          static void gapBondMgrInvertCharCfgItem( gapBondCharCfg_t *charCfgTbl )
   1321          {
   1322            for ( uint8 i = 0; i < GAP_CHAR_CFG_MAX; i++ )
   1323            {
   1324              charCfgTbl[i].attrHandle = ~(charCfgTbl[i].attrHandle);
   1325              charCfgTbl[i].value = ~(charCfgTbl[i].value);
   1326            }
   1327          }
   1328          
   1329          /*********************************************************************
   1330           * @fn      gapBondMgrAddBond
   1331           *
   1332           * @brief   Save a bond from a GAP Auth Complete Event
   1333           *
   1334           * @param   pBondRec - basic bond record
   1335           * @param   pLocalLTK - LTK used by this device during pairing
   1336           * @param   pDevLTK - LTK used by the connected device during pairing
   1337           * @param   pIRK - IRK used by the connected device during pairing
   1338           * @param   pSRK - SRK used by the connected device during pairing
   1339           * @param   signCounter - Sign counter used by the connected device during pairing
   1340           *
   1341           * @return  TRUE, if done processing bond record. FALSE, otherwise.
   1342           */
   1343          static uint8 gapBondMgrAddBond( gapBondRec_t *pBondRec, gapAuthCompleteEvent_t *pPkt )
   1344          { 
   1345            // See if this is a new bond record
   1346            if ( pAuthEvt == NULL )
   1347            {
   1348              // Make sure we have bonding info
   1349              if ( ( pBondRec == NULL ) || ( pPkt == NULL ) )
   1350              {
   1351                return ( TRUE );
   1352              }
   1353          
   1354              // First see if we already have an existing bond for this device
   1355              bondIdx = gapBondMgrFindAddr( pBondRec->publicAddr );
   1356              if ( bondIdx >= GAP_BONDINGS_MAX )
   1357              {
   1358                bondIdx = gapBondMgrFindEmpty();
   1359              }
   1360            }
   1361          
   1362            if ( bondIdx < GAP_BONDINGS_MAX )
   1363            { 
   1364              // See if this is a new bond record
   1365              if ( pAuthEvt == NULL )
   1366              {
   1367                gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX];
   1368                
   1369                // Save the main information
   1370                VOID osal_snv_write( mainRecordNvID(bondIdx), sizeof ( gapBondRec_t ), pBondRec );
   1371              
   1372                // Write out FF's over the charactersitic configuration entry, to overwrite
   1373                // any previous bond data that may have been stored
   1374                VOID osal_memset( charCfg, 0xFF, sizeof ( charCfg ) );
   1375          
   1376                VOID osal_snv_write( gattCfgNvID(bondIdx), sizeof ( charCfg ), charCfg );
   1377          
   1378                // Update Bond RAM Shadow just with the newly added bond entry
   1379                VOID osal_memcpy( &(bonds[bondIdx]), pBondRec, sizeof ( gapBondRec_t ) );
   1380                
   1381                // Keep the OSAL message to store the security keys later - will be freed then
   1382                pAuthEvt = pPkt;
   1383              }
   1384              else
   1385              {
   1386                // If available, save the LTK information
   1387                if ( pAuthEvt->pSecurityInfo )
   1388                {
   1389                  VOID osal_snv_write( localLTKNvID(bondIdx), sizeof ( gapBondLTK_t ), pAuthEvt->pSecurityInfo );
   1390                  pAuthEvt->pSecurityInfo = NULL;
   1391                }
   1392                // If availabe, save the connected device's LTK information
   1393                else if ( pAuthEvt->pDevSecInfo )
   1394                {
   1395                  VOID osal_snv_write( devLTKNvID(bondIdx), sizeof ( gapBondLTK_t ), pAuthEvt->pDevSecInfo );
   1396                  pAuthEvt->pDevSecInfo = NULL;
   1397                }
   1398                // If available, save the connected device's IRK
   1399                else if ( pAuthEvt->pIdentityInfo )
   1400                {
   1401                  VOID osal_snv_write( devIRKNvID(bondIdx), KEYLEN, pAuthEvt->pIdentityInfo->irk );
   1402                  pAuthEvt->pIdentityInfo = NULL;
   1403                }
   1404                // If available, save the connected device's Signature information
   1405                else if ( pAuthEvt->pSigningInfo )
   1406                {
   1407                  VOID osal_snv_write( devCSRKNvID(bondIdx), KEYLEN, pAuthEvt->pSigningInfo->srk );    
   1408                  VOID osal_snv_write( devSignCounterNvID(bondIdx), sizeof ( uint32 ), &(pAuthEvt->pSigningInfo->signCounter) );
   1409                  pAuthEvt->pSigningInfo = NULL;
   1410                }
   1411                else
   1412                {
   1413                  if ( autoSyncWhiteList )
   1414                  {
   1415                    gapBondMgr_SyncWhiteList();
   1416                  }
   1417          
   1418                  // Update the GAP Privacy Flag Properties
   1419                  gapBondSetupPrivFlag();
   1420                  
   1421                  return ( TRUE );
   1422                }
   1423              }
   1424              
   1425              // We have more info to store
   1426              return ( FALSE );
   1427            }
   1428          
   1429            return ( TRUE );
   1430          }
   1431          
   1432          /*********************************************************************
   1433           * @fn      gapBondMgrGetStateFlags
   1434           *
   1435           * @brief   Gets the state flags field of a bond record in NV
   1436           *
   1437           * @param   idx
   1438           *
   1439           * @return  stateFlags field
   1440           */
   1441          static uint8 gapBondMgrGetStateFlags( uint8 idx )
   1442          {
   1443            gapBondRec_t bondRec;
   1444          
   1445            if ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
   1446            {
   1447              return ( bondRec.stateFlags );
   1448            }
   1449          
   1450            return ( 0 );
   1451          }
   1452          
   1453          /*********************************************************************
   1454           * @fn      gapBondMgrGetPublicAddr
   1455           *
   1456           * @brief   Copy the public Address from a bonding record
   1457           *
   1458           * @param   idx - Bond record index
   1459           * @param   pAddr - a place to put the public address from NV
   1460           *
   1461           * @return  SUCCESS if successful.
   1462           *          Otherwise failure.
   1463           */
   1464          static bStatus_t gapBondMgrGetPublicAddr( uint8 idx, uint8 *pAddr )
   1465          {
   1466            bStatus_t stat;         // return value
   1467            gapBondRec_t bondRec;   // Work space for main bond record
   1468          
   1469            // Check parameters
   1470            if ( (idx >= GAP_BONDINGS_MAX) || (pAddr == NULL) )
   1471            {
   1472              return ( INVALIDPARAMETER );
   1473            }
   1474          
   1475            stat = osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
   1476          
   1477            if ( stat == SUCCESS )
   1478            {
   1479              VOID osal_memcpy( pAddr, bondRec.publicAddr, B_ADDR_LEN );
   1480            }
   1481          
   1482            return ( stat );
   1483          }
   1484          
   1485          /*********************************************************************
   1486           * @fn      gapBondMgrFindReconnectAddr
   1487           *
   1488           * @brief   Look through the bonding entries to find a
   1489           *          reconnection address.
   1490           *
   1491           * @param   pReconnectAddr - device address to look for
   1492           *
   1493           * @return  index to found bonding (0 - (GAP_BONDINGS_MAX-1),
   1494           *          GAP_BONDINGS_MAX if no empty entries
   1495           */
   1496          static uint8 gapBondMgrFindReconnectAddr( uint8 *pReconnectAddr )
   1497          {
   1498            // Item doesn't exist, so create all the items
   1499            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1500            {
   1501              // compare reconnection address
   1502              if ( osal_memcmp( bonds[idx].reconnectAddr, pReconnectAddr, B_ADDR_LEN ) )
   1503              {
   1504                return ( idx ); // Found it
   1505              }
   1506            }
   1507          
   1508            return ( GAP_BONDINGS_MAX );
   1509          }
   1510          
   1511          /*********************************************************************
   1512           * @fn      gapBondMgrFindAddr
   1513           *
   1514           * @brief   Look through the bonding entries to find an address.
   1515           *
   1516           * @param   pDevAddr - device address to look for
   1517           *
   1518           * @return  index to empty bonding (0 - (GAP_BONDINGS_MAX-1),
   1519           *          GAP_BONDINGS_MAX if no empty entries
   1520           */
   1521          static uint8 gapBondMgrFindAddr( uint8 *pDevAddr )
   1522          {
   1523            // Item doesn't exist, so create all the items
   1524            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1525            {
   1526              // Read in NV Main Bond Record and compare public address
   1527              if ( osal_memcmp( bonds[idx].publicAddr, pDevAddr, B_ADDR_LEN ) )
   1528              {
   1529                return ( idx ); // Found it
   1530              }
   1531            }
   1532          
   1533            return ( GAP_BONDINGS_MAX );
   1534          }
   1535          
   1536          /*********************************************************************
   1537           * @fn      gapBondMgrResolvePrivateAddr
   1538           *
   1539           * @brief   Look through the NV bonding entries to resolve a private
   1540           *          address.
   1541           *
   1542           * @param   pDevAddr - device address to look for
   1543           *
   1544           * @return  index to found bonding (0 - (GAP_BONDINGS_MAX-1),
   1545           *          GAP_BONDINGS_MAX if no entry found
   1546           */
   1547          static uint8 gapBondMgrResolvePrivateAddr( uint8 *pDevAddr )
   1548          {
   1549            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1550            {
   1551              uint8 IRK[KEYLEN];
   1552          
   1553              // Read in NV IRK Record and compare resovable address
   1554              if ( osal_snv_read( devIRKNvID(idx), KEYLEN, IRK ) == SUCCESS )
   1555              {
   1556                if ( ( osal_isbufset( IRK, 0xFF, KEYLEN ) == FALSE ) &&
   1557                     ( GAP_ResolvePrivateAddr( IRK, pDevAddr ) == SUCCESS ) )
   1558                {
   1559                  return ( idx ); // Found it
   1560                }
   1561              }
   1562            }
   1563          
   1564            return ( GAP_BONDINGS_MAX );
   1565          }
   1566          
   1567          /*********************************************************************
   1568           * @fn      gapBondMgrReadBonds
   1569           *
   1570           * @brief   Read through NV and store them in RAM.
   1571           *
   1572           * @param   none
   1573           *
   1574           * @return  none
   1575           */
   1576          static void gapBondMgrReadBonds( void )
   1577          {
   1578            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1579            {
   1580              // See if the entry exists in NV
   1581              if ( osal_snv_read( mainRecordNvID(idx), sizeof( gapBondRec_t ), &(bonds[idx]) ) != SUCCESS )
   1582              {
   1583                // Can't read the entry, assume that it doesn't exist
   1584                VOID osal_memset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN );
   1585                VOID osal_memset( bonds[idx].reconnectAddr, 0xFF, B_ADDR_LEN );
   1586                bonds[idx].stateFlags = 0;
   1587              }
   1588            }
   1589          
   1590            if ( autoSyncWhiteList )
   1591            {
   1592              gapBondMgr_SyncWhiteList();
   1593            }
   1594          
   1595            // Update the GAP Privacy Flag Properties
   1596            gapBondSetupPrivFlag();
   1597          }
   1598          
   1599          /*********************************************************************
   1600           * @fn      gapBondMgrFindEmpty
   1601           *
   1602           * @brief   Look through the bonding NV entries to find an empty.
   1603           *
   1604           * @param   none
   1605           *
   1606           * @return  index to empty bonding (0 - (GAP_BONDINGS_MAX-1),
   1607           *          GAP_BONDINGS_MAX if no empty entries
   1608           */
   1609          static uint8 gapBondMgrFindEmpty( void )
   1610          {
   1611            // Item doesn't exist, so create all the items
   1612            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1613            {
   1614              // Look for public address of all 0xFF's
   1615              if ( osal_isbufset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN ) )
   1616              {
   1617                return ( idx ); // Found one
   1618              }
   1619            }
   1620          
   1621            return ( GAP_BONDINGS_MAX );
   1622          }
   1623          
   1624          /*********************************************************************
   1625           * @fn      gapBondMgrBondTotal
   1626           *
   1627           * @brief   Look through the bonding NV entries calculate the number
   1628           *          entries.
   1629           *
   1630           * @param   none
   1631           *
   1632           * @return  total number of bonds found
   1633           */
   1634          static uint8 gapBondMgrBondTotal( void )
   1635          {
   1636            uint8 numBonds = 0;
   1637          
   1638            // Item doesn't exist, so create all the items
   1639            for ( uint8 idx = 0; idx < GAP_BONDINGS_MAX; idx++ )
   1640            {
   1641              // Look for public address that are not 0xFF's
   1642              if ( osal_isbufset( bonds[idx].publicAddr, 0xFF, B_ADDR_LEN ) == FALSE )
   1643              {
   1644                numBonds++; // Found one
   1645              }
   1646            }
   1647          
   1648            return ( numBonds );
   1649          }
   1650          
   1651          /*********************************************************************
   1652           * @fn      gapBondMgrEraseAllBondings
   1653           *
   1654           * @brief   Write all 0xFF's to all of the bonding entries
   1655           *
   1656           * @param   none
   1657           *
   1658           * @return  SUCCESS if successful.
   1659           *          Otherwise, NV_OPER_FAILED for failure.
   1660           */
   1661          static bStatus_t gapBondMgrEraseAllBondings( void )
   1662          {
   1663            bStatus_t stat = SUCCESS;  // return value
   1664          
   1665            // Item doesn't exist, so create all the items
   1666            for ( uint8 idx = 0; (idx < GAP_BONDINGS_MAX) && (stat == SUCCESS); idx++ )
   1667            {
   1668              // Erasing will write/create a bonding entry
   1669              stat = gapBondMgrEraseBonding( idx );
   1670            }
   1671          
   1672            return ( stat );
   1673          }
   1674          
   1675          /*********************************************************************
   1676           * @fn      gapBondMgrEraseBonding
   1677           *
   1678           * @brief   Write all 0xFF's to the complete bonding record
   1679           *
   1680           * @param   idx - bonding index
   1681           *
   1682           * @return  SUCCESS if successful.
   1683           *          Otherwise, NV_OPER_FAILED for failure.
   1684           */
   1685          static bStatus_t gapBondMgrEraseBonding( uint8 idx )
   1686          {
   1687            bStatus_t ret;
   1688            gapBondRec_t bondRec;
   1689          
   1690            if ( idx == bondIdx )
   1691            {
   1692              // Stop ongoing bond store process to prevent any invalid data be written.
   1693              osal_clear_event( gapBondMgr_TaskID, GAP_BOND_SYNC_CC_EVT );
   1694              osal_clear_event( gapBondMgr_TaskID, GAP_BOND_SAVE_REC_EVT );
   1695          
   1696              gapBondFreeAuthEvt();
   1697            }
   1698            
   1699            // First see if bonding record exists in NV, then write all 0xFF's to it
   1700            if ( ( osal_snv_read( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec ) == SUCCESS )
   1701                 && (osal_isbufset( bondRec.publicAddr, 0xFF, B_ADDR_LEN ) == FALSE) )
   1702            {
   1703              gapBondLTK_t ltk;
   1704              gapBondCharCfg_t charCfg[GAP_CHAR_CFG_MAX];
   1705          
   1706              VOID osal_memset( &bondRec, 0xFF, sizeof ( gapBondRec_t ) );
   1707              VOID osal_memset( &ltk, 0xFF, sizeof ( gapBondLTK_t ) );
   1708          
   1709              VOID osal_memset( charCfg, 0xFF, sizeof ( charCfg ) );
   1710          
   1711              // Write out FF's over the entire bond entry.
   1712              ret = osal_snv_write( mainRecordNvID(idx), sizeof ( gapBondRec_t ), &bondRec );
   1713              ret |= osal_snv_write( localLTKNvID(idx), sizeof ( gapBondLTK_t ), &ltk );
   1714              ret |= osal_snv_write( devLTKNvID(idx), sizeof ( gapBondLTK_t ), &ltk );
   1715              ret |= osal_snv_write( devIRKNvID(idx), KEYLEN, ltk.LTK );
   1716              ret |= osal_snv_write( devCSRKNvID(idx), KEYLEN, ltk.LTK );
   1717              ret |= osal_snv_write( devSignCounterNvID(idx), sizeof ( uint32 ), ltk.LTK );
   1718          
   1719              // Write out FF's over the charactersitic configuration entry.
   1720              ret |= osal_snv_write( gattCfgNvID(idx), sizeof ( charCfg ), charCfg );
   1721            }
   1722            else
   1723            {
   1724              ret = SUCCESS;
   1725            }
   1726          
   1727            return ( ret );
   1728          }
   1729          
   1730          /*********************************************************************
   1731           * @brief   Task Initialization function.
   1732           *
   1733           * Internal function defined in gapbondmgr.h.
   1734           */
   1735          void GAPBondMgr_Init( uint8 task_id )
   1736          {
   1737            gapBondMgr_TaskID = task_id;  // Save task ID
   1738          
   1739            // Setup Bond RAM Shadow
   1740            gapBondMgrReadBonds();
   1741          }
   1742          
   1743          /*********************************************************************
   1744           * @brief   Task Event Processor function.
   1745           *
   1746           * Internal function defined in gapbondmgr.h.
   1747           */
   1748          uint16 GAPBondMgr_ProcessEvent( uint8 task_id, uint16 events )
   1749          {
   1750            VOID task_id; // OSAL required parameter that isn't used in this function
   1751          
   1752            if ( events & SYS_EVENT_MSG )
   1753            {
   1754              uint8 *pMsg;
   1755          
   1756              if ( (pMsg = osal_msg_receive( gapBondMgr_TaskID )) != NULL )
   1757              {
   1758                if ( gapBondMgr_ProcessOSALMsg( (osal_event_hdr_t *)pMsg ) )
   1759                {
   1760                  // Release the OSAL message
   1761                  VOID osal_msg_deallocate( pMsg );
   1762                }
   1763              }
   1764          
   1765              // return unprocessed events
   1766              return (events ^ SYS_EVENT_MSG);
   1767            }
   1768          
   1769            if ( events & GAP_BOND_SAVE_REC_EVT )
   1770            {
   1771              // Save bonding record in NV
   1772              if ( gapBondMgrAddBond( NULL, NULL ) )
   1773              {      
   1774                // Notify our task to update NV with CCC values stored in GATT database
   1775                osal_set_event( gapBondMgr_TaskID, GAP_BOND_SYNC_CC_EVT );
   1776                     
   1777                return (events ^ GAP_BOND_SAVE_REC_EVT);
   1778              }
   1779          
   1780              return ( GAP_BOND_SAVE_REC_EVT );
   1781            }
   1782            
   1783            if ( events & GAP_BOND_SYNC_CC_EVT )
   1784            {
   1785              // Update NV to have same CCC values as GATT database
   1786              // Note: pAuthEvt is a global variable used for deferring the storage
   1787              if ( gapBondMgr_SyncCharCfg( pAuthEvt->connectionHandle ) )
   1788              {      
   1789                if ( pGapBondCB && pGapBondCB->pairStateCB )
   1790                {
   1791                  // Assume SUCCESS since we got this far.
   1792                  pGapBondCB->pairStateCB( pAuthEvt->connectionHandle, GAPBOND_PAIRING_STATE_COMPLETE, SUCCESS );
   1793                }
   1794                
   1795                // We're done storing bond record and CCC values in NV
   1796                gapBondFreeAuthEvt();
   1797              
   1798                return (events ^ GAP_BOND_SYNC_CC_EVT);
   1799              }
   1800              
   1801              return ( GAP_BOND_SYNC_CC_EVT );
   1802            }
   1803          
   1804            // Discard unknown events
   1805            return 0;
   1806          }
   1807          
   1808          /*********************************************************************
   1809           * @fn      gapBondMgr_ProcessOSALMsg
   1810           *
   1811           * @brief   Process an incoming task message.
   1812           *
   1813           * @param   pMsg - message to process
   1814           *
   1815           * @return  TRUE if safe to deallocate incoming message, FALSE otherwise.
   1816           */
   1817          static uint8 gapBondMgr_ProcessOSALMsg( osal_event_hdr_t *pMsg )
   1818          {
   1819            uint8 safeToDealloc = TRUE;
   1820            
   1821            switch ( pMsg->event )
   1822            {
   1823              case GAP_MSG_EVENT:
   1824                safeToDealloc = GAPBondMgr_ProcessGAPMsg( (gapEventHdr_t *)pMsg );
   1825                break;
   1826          
   1827              case GATT_MSG_EVENT:
   1828                gapBondMgr_ProcessGATTMsg( (gattMsgEvent_t *)pMsg );
   1829                break;
   1830          
   1831              case GATT_SERV_MSG_EVENT:
   1832                gapBondMgr_ProcessGATTServMsg( (gattEventHdr_t *)pMsg );
   1833                break;
   1834          
   1835              default:
   1836                break;
   1837            }
   1838            
   1839            return ( safeToDealloc );
   1840          }
   1841          
   1842          /*********************************************************************
   1843           * @fn      GAPBondMgr_CheckNVLen
   1844           *
   1845           * @brief   This function will check the length of an NV Item.
   1846           *
   1847           * @param   id - NV ID.
   1848           * @param   len - lengths in bytes of item.
   1849           *
   1850           * @return  SUCCESS or FAILURE
   1851           */
   1852          uint8 GAPBondMgr_CheckNVLen( uint8 id, uint8 len )
   1853          {
   1854            uint8 stat = FAILURE;
   1855          
   1856            // Convert to index
   1857            switch ( (id - BLE_NVID_GAP_BOND_START) % GAP_BOND_REC_IDS )
   1858            {
   1859              case GAP_BOND_REC_ID_OFFSET:
   1860                if ( len == sizeof ( gapBondRec_t ) )
   1861                {
   1862                  stat = SUCCESS;
   1863                }
   1864                break;
   1865          
   1866              case GAP_BOND_LOCAL_LTK_OFFSET:
   1867              case GAP_BOND_DEV_LTK_OFFSET:
   1868                if ( len == sizeof ( gapBondLTK_t ) )
   1869                {
   1870                  stat = SUCCESS;
   1871                }
   1872                break;
   1873          
   1874              case GAP_BOND_DEV_IRK_OFFSET:
   1875              case GAP_BOND_DEV_CSRK_OFFSET:
   1876                if ( len == KEYLEN )
   1877                {
   1878                  stat = SUCCESS;
   1879                }
   1880                break;
   1881          
   1882              case GAP_BOND_DEV_SIGN_COUNTER_OFFSET:
   1883                if ( len == sizeof ( uint32 ) )
   1884                {
   1885                  stat = SUCCESS;
   1886                }
   1887                break;
   1888          
   1889              default:
   1890                break;
   1891            }
   1892          
   1893            return ( stat );
   1894          }
   1895          
   1896          /*********************************************************************
   1897           * @fn          gapBondMgr_ProcessGATTMsg
   1898           *
   1899           * @brief       Process an incoming GATT message.
   1900           *
   1901           * @param       pMsg - pointer to received message
   1902           *
   1903           * @return      none
   1904           */
   1905          static void gapBondMgr_ProcessGATTMsg( gattMsgEvent_t *pMsg )
   1906          {
   1907            // Process the GATT message
   1908            switch ( pMsg->method )
   1909            {
   1910              case ATT_HANDLE_VALUE_CFM:
   1911                // Clear Service Changed flag for this client
   1912                VOID GAPBondMgr_ServiceChangeInd( pMsg->connHandle, 0x00 );
   1913                break;
   1914          
   1915              default:
   1916                // Unknown message
   1917                break;
   1918            }
   1919          }
   1920          
   1921          /*********************************************************************
   1922           * @fn          gapBondMgr_ProcessGATTServMsg
   1923           *
   1924           * @brief       Process an incoming GATT Server App message.
   1925           *
   1926           * @param       pMsg - pointer to received message
   1927           *
   1928           * @return      none
   1929           */
   1930          static void gapBondMgr_ProcessGATTServMsg( gattEventHdr_t *pMsg )
   1931          {
   1932            // Process the GATT Server App message
   1933            switch ( pMsg->method )
   1934            {
   1935              case GATT_CLIENT_CHAR_CFG_UPDATED_EVENT:
   1936                {
   1937                  gattClientCharCfgUpdatedEvent_t *pEvent = (gattClientCharCfgUpdatedEvent_t *)pMsg;
   1938          
   1939                  VOID GAPBondMgr_UpdateCharCfg( pEvent->connHandle, pEvent->attrHandle, pEvent->value );
   1940                }
   1941                break;
   1942          
   1943              default:
   1944                // Unknown message
   1945                break;
   1946            }
   1947          }
   1948          
   1949          /*********************************************************************
   1950           * @fn      gapBondMgrSendServiceChange
   1951           *
   1952           * @brief   Tell the GATT that a service change is needed.
   1953           *
   1954           * @param   pLinkItem - pointer to connection information
   1955           *
   1956           * @return  none
   1957           */
   1958          static void gapBondMgrSendServiceChange( linkDBItem_t *pLinkItem )
   1959          {
   1960            VOID GATTServApp_SendServiceChangedInd( pLinkItem->connectionHandle,
   1961                                                    gapBondMgr_TaskID );
   1962          }
   1963          
   1964          /*********************************************************************
   1965           * @fn      gapBondSetupPrivFlag
   1966           *
   1967           * @brief   Setup the GAP Privacy Flag properties.
   1968           *
   1969           * @param   none
   1970           *
   1971           * @return  none
   1972           */
   1973          static void gapBondSetupPrivFlag( void )
   1974          {
   1975            uint8 privFlagProp;
   1976          
   1977            if ( gapBondMgrBondTotal() > 1 )
   1978            {
   1979              privFlagProp = GATT_PROP_READ;
   1980            }
   1981            else
   1982            {
   1983              privFlagProp = GATT_PROP_READ | GATT_PROP_WRITE;
   1984            }
   1985          
   1986            // Setup the
   1987            VOID GGS_SetParameter( GGS_PERI_PRIVACY_FLAG_PROPS, sizeof ( uint8 ), &privFlagProp );
   1988          }
   1989          
   1990          /*********************************************************************
   1991           * @fn      gapBondMgrAuthenticate
   1992           *
   1993           * @brief   Initiate authentication
   1994           *
   1995           * @param   connHandle - connection handle
   1996           * @param   addrType - peer address type
   1997           * @param   pPairReq - Enter these parameters if the Pairing Request was already received.
   1998           *          NULL, if waiting for Pairing Request or if initiating.
   1999           *
   2000           * @return  none
   2001           */
   2002          static void gapBondMgrAuthenticate( uint16 connHandle, uint8 addrType,
   2003                                              gapPairingReq_t *pPairReq )
   2004          {
   2005            gapAuthParams_t params;
   2006          
   2007            VOID osal_memset( &params, 0, sizeof ( gapAuthParams_t ) );
   2008          
   2009            // Setup the pairing parameters
   2010            params.connectionHandle = connHandle;
   2011            params.secReqs.ioCaps = gapBond_IOCap;
   2012            params.secReqs.oobAvailable = gapBond_OOBDataFlag;
   2013            params.secReqs.maxEncKeySize = gapBond_KeySize;
   2014          
   2015            params.secReqs.keyDist.sEncKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_SENCKEY) ? TRUE : FALSE;
   2016            params.secReqs.keyDist.sIdKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_SIDKEY) ? TRUE : FALSE;
   2017            params.secReqs.keyDist.mEncKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_MENCKEY) ? TRUE : FALSE;
   2018            params.secReqs.keyDist.mIdKey = (gapBond_KeyDistList & GAPBOND_KEYDIST_MIDKEY) ? TRUE : FALSE;
   2019            params.secReqs.keyDist.mSign = (gapBond_KeyDistList & GAPBOND_KEYDIST_MSIGN) ? TRUE : FALSE;
   2020            params.secReqs.keyDist.sSign = (gapBond_KeyDistList & GAPBOND_KEYDIST_SSIGN) ? TRUE : FALSE;
   2021          
   2022            // Is bond manager setup for OOB data?
   2023            if ( gapBond_OOBDataFlag )
   2024            {
   2025              VOID osal_memcpy( params.secReqs.oob, gapBond_OOBData, KEYLEN );
   2026            }
   2027          
   2028            if ( gapBond_Bonding && addrType != ADDRTYPE_PUBLIC )
   2029            {
   2030              // Force a slave ID key
   2031              params.secReqs.keyDist.sIdKey = TRUE;
   2032            }
   2033          
   2034            params.secReqs.authReq |= (gapBond_Bonding) ? SM_AUTH_STATE_BONDING : 0;
   2035            params.secReqs.authReq |= (gapBond_MITM) ? SM_AUTH_STATE_AUTHENTICATED : 0;
   2036          
   2037            VOID GAP_Authenticate( &params, pPairReq );
   2038          }
   2039          
   2040          #if ( HOST_CONFIG & PERIPHERAL_CFG )
   2041          /*********************************************************************
   2042           * @fn      gapBondMgrSlaveSecurityReq
   2043           *
   2044           * @brief   Send a slave security request
   2045           *
   2046           * @param   connHandle - connection handle
   2047           *
   2048           * @return  none
   2049           */
   2050          static void gapBondMgrSlaveSecurityReq( uint16 connHandle )
   2051          {
   2052            uint8 authReq = 0;
   2053          
   2054            authReq |= (gapBond_Bonding) ? SM_AUTH_STATE_BONDING : 0;
   2055            authReq |= (gapBond_MITM) ? SM_AUTH_STATE_AUTHENTICATED : 0;
   2056          
   2057            VOID GAP_SendSlaveSecurityRequest( connHandle, authReq );
   2058          }
   2059          #endif
   2060          
   2061          /*********************************************************************
   2062           * @fn      gapBondMgrBondReq
   2063           *
   2064           * @brief   Initiate a GAP bond request
   2065           *
   2066           * @param   connHandle - connection handle
   2067           * @param   idx - NV index of bond entry
   2068           * @param   stateFlags - bond state flags
   2069           * @param   role - master or slave role
   2070           * @param   startEncryption - whether or not to start encryption
   2071           *
   2072           * @return  none
   2073           */
   2074          static void gapBondMgrBondReq( uint16 connHandle, uint8 idx, uint8 stateFlags,
   2075                                         uint8 role, uint8 startEncryption )
   2076          {
   2077            smSecurityInfo_t ltk;
   2078            osalSnvId_t      nvId;
   2079          
   2080            if ( role == GAP_PROFILE_CENTRAL )
   2081            {
   2082              nvId = devLTKNvID( idx );
   2083            }
   2084            else
   2085            {
   2086              nvId = localLTKNvID( idx );
   2087            }
   2088          
   2089            // Initialize the NV structures
   2090            VOID osal_memset( &ltk, 0, sizeof ( smSecurityInfo_t ) );
   2091          
   2092            if ( osal_snv_read( nvId, sizeof ( smSecurityInfo_t ), &ltk ) == SUCCESS )
   2093            {
   2094              if ( (ltk.keySize >= MIN_ENC_KEYSIZE) && (ltk.keySize <= MAX_ENC_KEYSIZE) )
   2095              {
   2096                VOID GAP_Bond( connHandle,
   2097                              ((stateFlags & GAP_BONDED_STATE_AUTHENTICATED) ? TRUE : FALSE),
   2098                              &ltk, startEncryption );
   2099              }
   2100            }
   2101          }
   2102          
   2103          /*********************************************************************
   2104           * @fn      gapBondMgr_SyncWhiteList
   2105           *
   2106           * @brief   syncronize the White List with the bonds
   2107           *
   2108           * @param   none
   2109           *
   2110           * @return  none
   2111           */
   2112          static void gapBondMgr_SyncWhiteList( void )
   2113          {
   2114            //erase the White List
   2115            VOID HCI_LE_ClearWhiteListCmd();
   2116          
   2117            // Write bond addresses into the White List
   2118            for( uint8 i = 0; i < GAP_BONDINGS_MAX; i++)
   2119            {
   2120              // Make sure empty addresses are not added to the White List
   2121              if ( osal_isbufset( bonds[i].publicAddr, 0xFF, B_ADDR_LEN ) == FALSE )
   2122              {
   2123                VOID HCI_LE_AddWhiteListCmd( HCI_PUBLIC_DEVICE_ADDRESS, bonds[i].publicAddr );
   2124              }
   2125            }
   2126          }
   2127          
   2128          /*********************************************************************
   2129           * @fn          gapBondMgr_SyncCharCfg
   2130           *
   2131           * @brief       Update the Bond Manager to have the same configurations as
   2132           *              the GATT database.
   2133           *
   2134           * @param       connHandle - the current connection handle to find client configurations for
   2135           *
   2136           * @return      TRUE if sync done. FALSE, otherwise.
   2137           */
   2138          static uint8 gapBondMgr_SyncCharCfg( uint16 connHandle )
   2139          {
   2140            static gattAttribute_t *pAttr = NULL;
   2141            static uint16 service;
   2142          
   2143            // Only attributes with attribute handles between and including the Starting
   2144            // Handle parameter and the Ending Handle parameter that match the requested
   2145            // attribute type and the attribute value will be returned.
   2146          
   2147            // All attribute types are effectively compared as 128-bit UUIDs,
   2148            // even if a 16-bit UUID is provided in this request or defined
   2149            // for an attribute.
   2150            if ( pAttr == NULL )
   2151            {
   2152              pAttr = GATT_FindHandleUUID( GATT_MIN_HANDLE, GATT_MAX_HANDLE,
   2153                                           clientCharCfgUUID, ATT_BT_UUID_SIZE, &service );
   2154            }
   2155            
   2156            if ( pAttr != NULL )
   2157            {
   2158              uint8 len;
   2159              uint8 attrVal[ATT_BT_UUID_SIZE];
   2160          
   2161              // It is not possible to use this request on an attribute that has a value
   2162              // that is longer than 2.
   2163              if ( GATTServApp_ReadAttr( connHandle, pAttr, service, attrVal,
   2164                                         &len, 0, ATT_BT_UUID_SIZE ) == SUCCESS )
   2165              {
   2166                uint16 value = BUILD_UINT16(attrVal[0], attrVal[1]);
   2167          
   2168                if ( value != GATT_CFG_NO_OPERATION )
   2169                {
   2170                  // NV must be updated to meet configuration of the database
   2171                  VOID GAPBondMgr_UpdateCharCfg( connHandle, pAttr->handle, value );
   2172                }
   2173              }
   2174          
   2175              // Try to find the next attribute
   2176              pAttr = GATT_FindNextAttr( pAttr, GATT_MAX_HANDLE, service, NULL );
   2177            }
   2178            
   2179            return ( pAttr == NULL );    
   2180          }
   2181          
   2182          /*********************************************************************
   2183           * @fn          gapBondFreeAuthEvt
   2184           *
   2185           * @brief       Free GAP Authentication Complete event.
   2186           *
   2187           * @param       none
   2188           *
   2189           * @return      none
   2190           */
   2191          static void gapBondFreeAuthEvt( void )
   2192          {
   2193            if ( pAuthEvt != NULL )
   2194            {
   2195              // Release the OSAL message
   2196              VOID osal_msg_deallocate( (uint8 *)pAuthEvt );
   2197              pAuthEvt = NULL;
   2198            }
   2199            
   2200            bondIdx = GAP_BONDINGS_MAX;
   2201          }
   2202          
   2203          #endif // ( CENTRAL_CFG | PERIPHERAL_CFG )
   2204          
   2205          /*********************************************************************
   2206          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     10  GAPBondMgr_CheckNVLen
       1      0     14  GAPBondMgr_GetParameter
                          0 0 12 -> GAP_GetParamValue
                          0 0 12 -> gapBondMgrBondTotal
                          0 0 14 -> osal_memcpy
       0      0      9  GAPBondMgr_Init
                          0 0  9 -> gapBondMgrReadBonds
       2      0     71  GAPBondMgr_LinkEst
                          0 0 68 -> GAPBondMgr_ResolveAddr
                          0 0 68 -> GAP_SendSlaveSecurityRequest
                          0 0 68 -> GAP_Signable
                          0 0 68 -> GATTServApp_SendServiceChangedInd
                          0 0 70 -> GATTServApp_UpdateCharCfg
                          0 0 69 -> gapBondMgrBondReq
                          0 0 68 -> gapBondMgrInvertCharCfgItem
                          0 0 68 -> osal_isbufset
                          0 0 68 -> osal_memset
                          0 0 68 -> osal_snv_read
       0      0     26  GAPBondMgr_PasscodeRsp
                          0 0 22 -> GAP_PasscodeUpdate
                          0 0 20 -> GAP_TerminateAuth
       0      0     14  GAPBondMgr_ProcessEvent
                          0 0 12 -> GAPBondMgr_ProcessGAPMsg
                          0 0 12 -> GAPBondMgr_ServiceChangeInd
                          0 0 14 -> GAPBondMgr_UpdateCharCfg
                          0 0 12 -> gapBondFreeAuthEvt
                          0 0 12 -> gapBondMgrAddBond
                          0 0 12 -> gapBondMgr_SyncCharCfg
                          0 0 12 -> osal_msg_deallocate
                          0 0 12 -> osal_msg_receive
                          0 0 12 -> osal_set_event
       0      0     50  GAPBondMgr_ProcessGAPMsg
                          0 0 36 -> GAPBondMgr_ResolveAddr
                          0 0 36 -> GAP_NumActiveConnections
                          0 0 38 -> GAP_PasscodeUpdate
                          0 0 36 -> GAP_TerminateAuth
                          0 0 36 -> gapBondMgrAddBond
                          0 0 36 -> gapBondMgrAuthenticate
                          0 0 36 -> gapBondMgrEraseAllBondings
                          0 0 36 -> gapBondMgrEraseBonding
                          0 0 36 -> gapBondMgrReadBonds
                          0 0 36 -> linkDB_Find
                          0 0 38 -> osal_memcpy
                          0 0 36 -> osal_memset
                          0 0 36 -> osal_set_event
                          0 0 36 -> osal_snv_compact
                          0 0 36 -> osal_snv_write
       2      0      0  GAPBondMgr_Register
                          2 0  0 -> GAP_SetParamValue
                          2 0  0 -> GATTServApp_RegisterForMsg
       0      0     86  GAPBondMgr_ResolveAddr
                          0 0 16 -> gapBondMgrFindAddr
                          0 0 16 -> gapBondMgrGetPublicAddr
                          0 0 16 -> gapBondMgrResolvePrivateAddr
                          0 0 18 -> osal_memcmp
                          0 0 18 -> osal_memcpy
       0      0     24  GAPBondMgr_ServiceChangeInd
                          0 0 12 -> GAPBondMgr_ResolveAddr
                          0 0 12 -> gapBondMgrChangeState
                          0 0 12 -> gapBondMgrSendServiceChange
                          0 0 12 -> linkDB_Find
                          0 0 12 -> linkDB_PerformFunc
       0      0     24  GAPBondMgr_SetParameter
                          0 0 22 -> GAPBondMgr_ResolveAddr
                          0 0 22 -> GAP_NumActiveConnections
                          0 0 22 -> GAP_SetParamValue
                          0 0 22 -> gapBondMgrEraseAllBondings
                          0 0 22 -> gapBondMgrEraseBonding
                          0 0 22 -> gapBondMgrReadBonds
                          0 0 24 -> osal_memcpy
                          0 0 24 -> osal_revmemcpy
                          0 0 22 -> osal_snv_compact
       0      0     29  GAPBondMgr_UpdateCharCfg
                          0 0 14 -> GAPBondMgr_ResolveAddr
                          0 0 14 -> gapBondMgrUpdateCharCfg
                          0 0 14 -> linkDB_Find
       2      0     66  gapBondFreeAuthEvt
                          2 0  0 -> osal_msg_deallocate
       0      0     64  gapBondMgrAddBond
                          0 0 26 -> gapBondMgrFindAddr
                          0 0 26 -> gapBondMgr_SyncWhiteList
                          0 0 26 -> gapBondSetupPrivFlag
                          0 0 26 -> osal_isbufset
                          0 0 28 -> osal_memcpy
                          0 0 26 -> osal_memset
                          0 0 26 -> osal_snv_write
       1      0     76  gapBondMgrAuthenticate
                          0 0 38 -> GAP_Authenticate
                          0 0 40 -> osal_memcpy
                          0 0 38 -> osal_memset
       0      0    110  gapBondMgrBondReq
                          0 0 41 -> GAP_Bond
                          0 0 40 -> osal_memset
                          0 0 40 -> osal_snv_read
       0      0     21  gapBondMgrBondTotal
                          0 0  9 -> osal_isbufset
       0      0     38  gapBondMgrChangeState
                          0 0 26 -> osal_isbufset
                          0 0 26 -> osal_snv_read
                          0 0 26 -> osal_snv_write
       0      0     45  gapBondMgrEraseAllBondings
                          0 0  9 -> gapBondMgrEraseBonding
       0      0    102  gapBondMgrEraseBonding
                          0 0 66 -> gapBondFreeAuthEvt
                          0 0 66 -> osal_clear_event
                          0 0 66 -> osal_isbufset
                          0 0 66 -> osal_memset
                          0 0 66 -> osal_snv_read
                          0 0 66 -> osal_snv_write
       0      0     40  gapBondMgrFindAddr
                          0 0 14 -> osal_memcmp
       0      0     49  gapBondMgrFindCharCfgItem
       0      0     44  gapBondMgrGetPublicAddr
                          0 0 28 -> osal_memcpy
                          0 0 26 -> osal_snv_read
       1      0     77  gapBondMgrInvertCharCfgItem
       0      0     45  gapBondMgrReadBonds
                          0 0  9 -> gapBondMgr_SyncWhiteList
                          0 0  9 -> gapBondSetupPrivFlag
                          0 0  9 -> osal_memset
                          0 0  9 -> osal_snv_read
       0      0     41  gapBondMgrResolvePrivateAddr
                          0 0 25 -> GAP_ResolvePrivateAddr
                          0 0 25 -> osal_isbufset
                          0 0 25 -> osal_snv_read
       2      0     12  gapBondMgrSendServiceChange
                          2 0  0 -> GATTServApp_SendServiceChangedInd
       1      0     54  gapBondMgrUpdateCharCfg
                          0 0 40 -> gapBondMgrFindCharCfgItem
                          0 0 40 -> gapBondMgrInvertCharCfgItem
                          0 0 40 -> osal_isbufset
                          0 0 40 -> osal_memset
                          0 0 40 -> osal_snv_read
                          0 0 40 -> osal_snv_write
       0      0     33  gapBondMgr_SyncCharCfg
                          0 0 15 -> GAPBondMgr_UpdateCharCfg
                          0 0 21 -> GATTServApp_ReadAttr
                          0 0 19 -> GATT_FindHandleUUID
                          0 0 17 -> GATT_FindNextAttr
       0      0     35  gapBondMgr_SyncWhiteList
                          0 0  9 -> HCI_LE_AddWhiteListCmd
                          0 0  9 -> HCI_LE_ClearWhiteListCmd
                          0 0  9 -> osal_isbufset
       2      0     27  gapBondSetupPrivFlag
                          2 0  1 -> GGS_SetParameter
                          2 0  1 -> gapBondMgrBondTotal


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       6  ?<Constant {0, 0, 0, 0, 0, 0}>
       1  ?<Initializer for bondIdx>
       1  ?<Initializer for gapBond_AutoFailReason>
       2  ?<Initializer for gapBond_InitiateWait>
       1  ?<Initializer for gapBond_KeyDistList>
       1  ?<Initializer for gapBond_KeySize>
       1  ?<Initializer for gapBond_PairingMode>
       6  ??GAPBondMgr_CheckNVLen?relay
       6  ??GAPBondMgr_GetParameter?relay
       6  ??GAPBondMgr_Init?relay
       6  ??GAPBondMgr_LinkEst?relay
       6  ??GAPBondMgr_PasscodeRsp?relay
       6  ??GAPBondMgr_ProcessEvent?relay
       6  ??GAPBondMgr_ProcessGAPMsg?relay
       6  ??GAPBondMgr_Register?relay
       6  ??GAPBondMgr_ResolveAddr?relay
       6  ??GAPBondMgr_ServiceChangeInd?relay
       6  ??GAPBondMgr_SetParameter?relay
       6  ??GAPBondMgr_UpdateCharCfg?relay
       5  ??Subroutine24_0
       5  ??Subroutine25_0
       6  ??Subroutine26_0
       6  ??Subroutine27_0
       6  ??Subroutine28_0
       8  ??Subroutine29_0
       6  ??Subroutine30_0
       5  ??Subroutine31_0
       8  ??Subroutine32_0
       6  ??gapBondFreeAuthEvt?relay
       6  ??gapBondMgrAddBond?relay
       6  ??gapBondMgrAuthenticate?relay
       6  ??gapBondMgrBondReq?relay
       6  ??gapBondMgrBondTotal?relay
       6  ??gapBondMgrChangeState?relay
       6  ??gapBondMgrEraseAllBondings?relay
       6  ??gapBondMgrEraseBonding?relay
       6  ??gapBondMgrFindAddr?relay
       6  ??gapBondMgrFindCharCfgItem?relay
       6  ??gapBondMgrGetPublicAddr?relay
       6  ??gapBondMgrInvertCharCfgItem?relay
       6  ??gapBondMgrReadBonds?relay
       6  ??gapBondMgrResolvePrivateAddr?relay
       6  ??gapBondMgrSendServiceChange?relay
       6  ??gapBondMgrUpdateCharCfg?relay
       6  ??gapBondMgr_SyncCharCfg?relay
       6  ??gapBondMgr_SyncWhiteList?relay
       6  ??gapBondSetupPrivFlag?relay
       3  ?Subroutine0
       5  ?Subroutine1
       7  ?Subroutine10
      15  ?Subroutine11
       3  ?Subroutine12
      11  ?Subroutine13
       9  ?Subroutine14
      10  ?Subroutine15
       8  ?Subroutine16
      10  ?Subroutine17
       6  ?Subroutine18
       7  ?Subroutine19
       3  ?Subroutine2
       9  ?Subroutine20
       7  ?Subroutine21
       6  ?Subroutine22
       8  ?Subroutine23
       7  ?Subroutine3
       5  ?Subroutine4
       8  ?Subroutine5
       5  ?Subroutine6
       3  ?Subroutine7
       6  ?Subroutine8
       3  ?Subroutine9
      73  GAPBondMgr_CheckNVLen
     216  GAPBondMgr_GetParameter
      16  GAPBondMgr_Init
     417  GAPBondMgr_LinkEst
      82  GAPBondMgr_PasscodeRsp
     267  GAPBondMgr_ProcessEvent
     814  GAPBondMgr_ProcessGAPMsg
      37  GAPBondMgr_Register
     180  GAPBondMgr_ResolveAddr
     137  GAPBondMgr_ServiceChangeInd
     603  GAPBondMgr_SetParameter
     133  GAPBondMgr_UpdateCharCfg
       4  __Constant_f4240
       1  autoSyncWhiteList
       1  bondIdx
     140  bonds
      10  bondsToDelete
       1  eraseAllBonds
      37  gapBondFreeAuthEvt
     400  gapBondMgrAddBond
     411  gapBondMgrAuthenticate
     141  gapBondMgrBondReq
      45  gapBondMgrBondTotal
     134  gapBondMgrChangeState
      24  gapBondMgrEraseAllBondings
     321  gapBondMgrEraseBonding
      73  gapBondMgrFindAddr
      51  gapBondMgrFindCharCfgItem
      93  gapBondMgrGetPublicAddr
      53  gapBondMgrInvertCharCfgItem
     113  gapBondMgrReadBonds
     107  gapBondMgrResolvePrivateAddr
      22  gapBondMgrSendServiceChange
     295  gapBondMgrUpdateCharCfg
     273  gapBondMgr_SyncCharCfg
      63  gapBondMgr_SyncWhiteList
       1  gapBondMgr_TaskID
      47  gapBondSetupPrivFlag
       1  gapBond_AutoFail
       1  gapBond_AutoFailReason
       1  gapBond_Bonding
       1  gapBond_IOCap
       2  gapBond_InitiateWait
       1  gapBond_KeyDistList
       1  gapBond_KeySize
       1  gapBond_MITM
      16  gapBond_OOBData
       1  gapBond_OOBDataFlag
       1  gapBond_PairingMode
       4  gapBond_Passcode
       2  pAttr
       2  pAuthEvt
       2  pGapBondCB
       2  service

 
 5 897 bytes in segment BANKED_CODE
   186 bytes in segment BANK_RELAYS
     7 bytes in segment XDATA_I
     7 bytes in segment XDATA_ID
    10 bytes in segment XDATA_ROM_C
   186 bytes in segment XDATA_Z
 
 6 090 bytes of CODE  memory
     6 bytes of CONST memory (+ 4 bytes shared)
   193 bytes of XDATA memory

Errors: none
Warnings: none
