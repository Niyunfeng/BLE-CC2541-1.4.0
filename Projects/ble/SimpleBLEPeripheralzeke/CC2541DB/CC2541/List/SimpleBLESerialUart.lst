###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             24/Feb/2014  16:24:06 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\Source\SimpleBLESerialUart #
#                          .c                                                 #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\config\b #
#                          uildComponents.cfg (-DBROADCASTER_CFG=0x01         #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheralzeke\CC2541DB\buildCo #
#                          nfig.cfg (-DHOST_CONFIG=PERIPHERAL_CFG             #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\Source\SimpleBLESerialUart #
#                          .c -D INT_HEAP_LEN=3074 -D HALNODEBUG -D           #
#                          OSAL_CBTIMER_NUM_TASKS=1 -D HAL_AES_DMA=TRUE -D    #
#                          HAL_DMA=TRUE -D POWER_SAVING -D xPLUS_BROADCASTER  #
#                          -D HAL_LCD=TRUE -D HAL_LED=TRUE -D HAL_UART=TRUE   #
#                          -lcN E:\TexasInstruments\BLE-CC254x-1.4.0\Projects #
#                          \ble\SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\ #
#                           -o E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\   #
#                          -e --debug --core=plain --dptr=16,1                #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\common\  #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\include\ #
#                           -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\C #
#                          omponents\hal\include\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\hal\target\CC2541EB\ -I                      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\osal\include\ -I E:\TexasInstruments\BLE-CC2 #
#                          54x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2 #
#                          541DB\..\..\..\..\Components\services\saddr\ -I    #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\include\ -I E:\TexasInstruments\BLE-CC25 #
#                          4x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC25 #
#                          41DB\..\..\..\..\Components\ble\controller\phy\    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Co #
#                          mponents\ble\controller\include\ -I                #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\..\..\Components\ble\host\ -I               #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\common\cc25 #
#                          40\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\comm #
#                          on\npi\npi_np\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\Profiles\Roles\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Si #
#                          mpleProfile\ -I E:\TexasInstruments\BLE-CC254x-1.4 #
#                          .0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB\. #
#                          .\..\Profiles\DevInfo\ -Ohz                        #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\Simpl #
#                          eBLESerialUart.lst                                 #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\Simple #
#                          BLESerialUart.r51                                  #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\Source\SimpleBLESerialUart.c
      1          #include "bcomdef.h"
      2          #include "OSAL.h"
      3          #include "OSAL_PwrMgr.h"
      4          
      5          #include "OnBoard.h"
      6          #include "hal_adc.h"
      7          #include "hal_lcd.h"
      8          #include "osal_snv.h"
      9          
     10          #include "hal_uart.h"
     11          
     12          #include "SimpleBLESerialUart.h"
     13          
     14          uint8 SBP_UART_STUDY_CMD = 0xE0;
     15          uint8 SBP_UART_STUDY_CMD_LEN = 1;
     16          
     17          UartState u_state;
     18          uint8 UartBuffer[SBP_UART_RX_BUF_SIZE];
     19          
     20          //static uint8 sendMsgTo_TaskID;
     21          
     22          /*该函数将会在任务函数的初始化函数中调用*/
     23          void SbpHalUART_Init(uint8 taskID) {
     24          	//调用uart初始化代码
     25          	SbpHalUARTInit();
     26          	//记录任务函数的taskID，备用
     27          	// sendMsgTo_TaskID = taskID;
     28          }
     29          
     30          /*uart初始化代码，配置串口的波特率、流控制等*/
     31          void SbpHalUARTInit() {
     32          	halUARTCfg_t uartConfig;
     33          
     34          	// configure UART
     35          	uartConfig.configured = TRUE;
     36          	uartConfig.baudRate = SBP_UART_BR; //波特率
     37          	uartConfig.flowControl = SBP_UART_FC; //流控制
     38          	uartConfig.flowControlThreshold = SBP_UART_FC_THRESHOLD; //流控制阈值，当开启flowControl时，该设置有效
     39          	uartConfig.rx.maxBufSize = SBP_UART_RX_BUF_SIZE; //uart接收缓冲区大小
     40          	uartConfig.tx.maxBufSize = SBP_UART_TX_BUF_SIZE; //uart发送缓冲区大小
     41          	uartConfig.idleTimeout = SBP_UART_IDLE_TIMEOUT;
     42          	uartConfig.intEnable = SBP_UART_INT_ENABLE; //是否开启中断
     43          	uartConfig.callBackFunc = SbpHalUARTReadCallback; //uart接收回调函数，在该函数中读取可用uart数据
     44          
     45          	// start UART
     46          	// Note: Assumes no issue opening UART port.
     47          	(void) HalUARTOpen(SBP_UART_PORT, &uartConfig);
     48          
     49          	return;
     50          }
     51          
     52          void studyCompletedAndBroadcastData() {
     53          	HalLcdWriteString("write ...", HAL_LCD_LINE_4);
     54          //	if (osal_snv_write(0xE0, UartBuffer[0], UartBuffer) == SUCCESS) {
     55          //		HalLcdWriteString("write ok", HAL_LCD_LINE_4);
     56          //	}
     57          }
     58          
     59          void SbpHalUARTRead(uint8 port, uint8 *buf, uint16 len);
     60          /*uart接收回调函数*/
     61          uint16 numBytes;
     62          uint16 i, point, irdatalen;
     63          uint8 pktBuffer[SBP_UART_RX_BUF_SIZE];
     64          uint8 UART_PORT_HAVE_READ = 0;
     65          
     66          void SbpHalUARTReadCallback(uint8 port, uint8 event) {
     67          	UART_PORT_HAVE_READ = 0;
     68          	//UART_HAL_DELAY(15000);
     69          	numBytes = Hal_UART_RxBufLen(port);
     70          	HalLcdWriteStringValue("numBytes", numBytes, 10, HAL_LCD_LINE_2);
     71          	if (numBytes > 0 && (u_state == IR_DATA_STUDY_CMD_START_BEGIN_STATE)) {
     72          		SbpHalUARTRead(port, pktBuffer, numBytes);
     73          		//HalLcdWriteStringValue("pktBuffer", pktBuffer[0], 16, HAL_LCD_LINE_3);
     74          		if (pktBuffer[0] == SBP_UART_STUDY_CMD) {
     75          			osal_memset(UartBuffer, 0, SBP_UART_RX_BUF_SIZE);
     76          			point = 0;
     77          			irdatalen = 0;
     78          			u_state = IR_DATA_STUDY_CMD_START_END_STATE;
     79          		}
     80          	} else if (numBytes > 0 && (u_state == IR_DATA_STUDY_CMD_START_END_STATE)) {
     81          		SbpHalUARTRead(port, pktBuffer, numBytes);
     82          		if (irdatalen == 0) {
     83          			irdatalen = pktBuffer[0];
     84          		}
     85          		osal_memcpy(UartBuffer + point, pktBuffer, numBytes);
     86          		point += numBytes;
     87          		if (irdatalen == point) {
     88          			u_state = IR_DATA_STUDY_CMD_RECV_END_STATE;
     89          			studyCompletedAndBroadcastData();
     90          		}
     91          	} else if (numBytes > 0 && (u_state == IR_DATA_SEND_BEGIN_STATE)) {
     92          		SbpHalUARTRead(port, pktBuffer, numBytes);
     93          		HalLcdWriteStringValue("send resp:", pktBuffer[0], 16, HAL_LCD_LINE_6);
     94          		u_state = IR_DATA_SEND_END_RESP_STATE;
     95          	}
     96          
     97          	if (numBytes > 0 && UART_PORT_HAVE_READ == 0) {
     98          		SbpHalUARTRead(port, pktBuffer, numBytes);
     99          		HalLcdWriteStringValue("HAVE_READ", pktBuffer[0], 16, HAL_LCD_LINE_6);
    100          	}
    101          }
    102          
    103          void SbpHalUARTRead(uint8 port, uint8 *buf, uint16 len) {
    104          	//UART_HAL_DELAY(1000);
    105          	HalUARTRead(port, pktBuffer, numBytes);
    106          	UART_PORT_HAVE_READ = 1;
    107          }
    108          
    109          //static uint8 data_len = 0, exsit_data_len = 0, send_times = 0, send_len = 0;
    110          //#define one_time_data_len 125
    111          void SbpHalUARTWrite(uint8 *pBuffer, uint16 length) {
    112          
    113          //	data_len = osal_strlen(pBuffer);
    114          //
    115          //	do {
    116          //
    117          //		if(Hal_UART_TxBufLen() > 0){
    118          //			continue;
    119          //		}
    120          //
    121          //		if (data_len <= one_time_data_len) {
    122          //			HalUARTWrite(SBP_UART_PORT, pBuffer, length);
    123          //			exsit_data_len = 0;
    124          //
    125          //		} else if (exsit_data_len == 0 || exsit_data_len >= one_time_data_len) {
    126          //			exsit_data_len = data_len - one_time_data_len;
    127          //			HalUARTWrite(SBP_UART_PORT, (pBuffer + (send_times * one_time_data_len)), one_time_data_len);
    128          //
    129          //		} else if (exsit_data_len > 0 && exsit_data_len < one_time_data_len) {
    130          //			HalUARTWrite(SBP_UART_PORT, (pBuffer + (send_times * one_time_data_len)), exsit_data_len);
    131          //			exsit_data_len = 0;
    132          //		} else {
    133          //		}
    134          //
    135          //		send_times++;
    136          //
    137          //	} while (exsit_data_len > 0);
    138          //
    139          //	data_len = 0;
    140          //	send_len = 0;
    141          //	exsit_data_len = 0;
    142          //	send_times = 0;
    143          
    144          	/*do {
    145          		UART_HAL_DELAY(10);
    146          	} while (Hal_UART_TxBufLen() > 0);*/
    147          
    148          	HalUARTWrite(SBP_UART_PORT, pBuffer, length);
    149          }

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0     29  SbpHalUARTInit
                          2 0 29 -> HalUARTOpen
       0      0     18  SbpHalUARTRead
                          0 0  9 -> HalUARTRead
       0      0     11  SbpHalUARTReadCallback
                          0 0 10 -> HalLcdWriteStringValue
                          0 0  9 -> Hal_UART_RxBufLen
                          0 0  9 -> SbpHalUARTRead
                          0 0 11 -> osal_memcpy
                          0 0  9 -> osal_memset
                          0 0  9 -> studyCompletedAndBroadcastData
       2      0      0  SbpHalUARTWrite
                          2 0  0 -> HalUARTWrite
       2      0      0  SbpHalUART_Init
                          2 0  0 -> SbpHalUARTInit
       2      0      9  studyCompletedAndBroadcastData
                          2 0  0 -> HalLcdWriteString


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      10  ?<Constant "HAVE_READ">
       9  ?<Constant "numBytes">
      11  ?<Constant "send resp:">
      10  ?<Constant "write ...">
       1  ?<Initializer for SBP_UART_STUDY_CMD>
       1  ?<Initializer for SBP_UART_STUDY_CMD_LEN>
       6  ??SbpHalUARTInit?relay
       6  ??SbpHalUARTRead?relay
       6  ??SbpHalUARTReadCallback?relay
       6  ??SbpHalUARTWrite?relay
       6  ??SbpHalUART_Init?relay
       8  ??Subroutine5_0
       6  ??studyCompletedAndBroadcastData?relay
       7  ?Subroutine0
       6  ?Subroutine1
       3  ?Subroutine2
      10  ?Subroutine3
      13  ?Subroutine4
       1  SBP_UART_STUDY_CMD
       1  SBP_UART_STUDY_CMD_LEN
     113  SbpHalUARTInit
      21  SbpHalUARTRead
     314  SbpHalUARTReadCallback
      12  SbpHalUARTWrite
       9  SbpHalUART_Init
       1  UART_PORT_HAVE_READ
     255  UartBuffer
       2  i
       2  irdatalen
       2  numBytes
     255  pktBuffer
       2  point
      13  studyCompletedAndBroadcastData
       1  u_state

 
 529 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   2 bytes in segment XDATA_I
   2 bytes in segment XDATA_ID
  40 bytes in segment XDATA_ROM_C
 520 bytes in segment XDATA_Z
 
 567 bytes of CODE  memory
  40 bytes of CONST memory
 522 bytes of XDATA memory

Errors: none
Warnings: 1
