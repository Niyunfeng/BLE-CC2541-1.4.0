###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             27/Mar/2014  17:28:52 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Components\ha #
#                          l\target\CC2540EB\hal_sleep.c                      #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheral\CC2541DB\..\..\config\build #
#                          Components.cfg (-DBROADCASTER_CFG=0x01             #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheral\CC2541DB\buildConfig #
#                          .cfg (-DHOST_CONFIG=PERIPHERAL_CFG                 #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Components\ha #
#                          l\target\CC2540EB\hal_sleep.c -D                   #
#                          INT_HEAP_LEN=3074 -D HALNODEBUG -D                 #
#                          OSAL_CBTIMER_NUM_TASKS=1 -D xHAL_AES_DMA=TRUE -D   #
#                          HAL_DMA=TRUE -D POWER_SAVING -D xPLUS_BROADCASTER  #
#                          -D HAL_LCD=TRUE -D HAL_LED=TRUE -D HAL_UART=FALSE  #
#                          -D HAL_ADC=TRUE -D HAL_SLEEP_DEBUG_LED -lcN        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\CC2541\List\ -o       #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\CC2541\Obj\ -e        #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheral\CC2541DB\..\..\common\ -I   #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\include\ -I     #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\hal\include\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\..\ #
#                          ..\..\..\Components\hal\target\CC2541EB\ -I        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\osal\include\ -I E:\TexasInstruments\BLE-CC254x- #
#                          1.4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\.. #
#                          \..\..\..\Components\services\saddr\ -I            #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\ble\include\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\..\ #
#                          ..\..\..\Components\ble\controller\phy\ -I         #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\ble\controller\include\ -I                       #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1.4.0 #
#                          \Projects\ble\SimpleBLEPeripheral\CC2541DB\..\..\. #
#                          .\..\Components\ble\host\ -I                       #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\common\cc2540\  #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheral\CC2541DB\..\..\common\npi\n #
#                          pi_np\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheral\CC2541DB\..\..\Profi #
#                          les\Roles\ -I E:\TexasInstruments\BLE-CC254x-1.4.0 #
#                          \Projects\ble\SimpleBLEPeripheral\CC2541DB\..\..\P #
#                          rofiles\SimpleProfile\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\Profiles\DevInf #
#                          o\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Project #
#                          s\ble\SimpleBLEPeripheral\CC2541DB\..\..\Profiles\ #
#                          Batt\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Proj #
#                          ects\ble\SimpleBLEPeripheral\CC2541DB\..\..\Profil #
#                          es\HIDDev\ -Ohz                                    #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\CC2541\List\hal_sleep #
#                          .lst                                               #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\CC2541\Obj\hal_sleep. #
#                          r51                                                #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Components\hal\target\CC2540EB\hal_sleep.c
      1          /*******************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2013-07-26 10:28:58 -0700 (Fri, 26 Jul 2013) $
      4            Revision:       $Revision: 34783 $
      5          
      6            Description:    This module contains the HAL power management procedures for
      7                            the CC2540.
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          *******************************************************************************/
     39          
     40          /*******************************************************************************
     41           * INCLUDES
     42           */
     43          #include "hal_lcd.h"
     44          #include "hal_types.h"
     45          #include "hal_mcu.h"
     46          #include "hal_board.h"
     47          #include "hal_sleep.h"
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "OSAL.h"
     51          #include "OSAL_Timers.h"
     52          #include "OSAL_Tasks.h"
     53          #include "OSAL_PwrMgr.h"
     54          #include "hal_drivers.h"
     55          #include "hal_assert.h"
     56          #include "ll_sleep.h"
     57          #include "ll_timer2.h"
     58          #include "ll_math.h"
     59          
     60          /*******************************************************************************
     61           * MACROS
     62           */
     63          
     64          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
     65          // Set CC2540 power mode; always use PM2.
     66          #define HAL_SLEEP_PREP_POWER_MODE(mode)                                        \
     67            st( SLEEPCMD &= ~PMODE; /* clear mode bits */                                \
     68                SLEEPCMD |= mode;   /* set mode bits   */                                \
     69                while (!(STLOAD & LDRDY));                                               \
     70                halSleepPconValue = PCON_IDLE;                                           \
     71              )
     72          #define HAL_SLEEP_SET_POWER_MODE()                                             \
     73            halSetSleepMode()
     74          
     75          #else // HAL_SLEEP_DEBUG_POWER_MODE
     76          
     77          // Debug: Don't set power mode, just block until sleep timer interrupt.
     78          #define HAL_SLEEP_PREP_POWER_MODE(mode)     /* nothing */
     79          #define HAL_SLEEP_SET_POWER_MODE()                                             \
     80            st( while(halSleepInt == FALSE);                                             \
     81                halSleepInt = FALSE;                                                     \
     82                HAL_DISABLE_INTERRUPTS();                                                \
     83              )
     84          #endif // !HAL_SLEEP_DEBUG_POWER_MODE
     85          
     86          // sleep timer interrupt control
     87          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)  // enable sleep timer interrupt
     88          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;) // disable sleep timer interrupt
     89          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(IRCON &= ~0x80;)   // clear sleep interrupt flag
     90          
     91          // backup interrupt enable registers before sleep
     92          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE( ien0, ien1, ien2 )                    \
     93            st( (ien0)  = IEN0;                                                          \
     94                (ien1)  = IEN1;                                                          \
     95                (ien2)  = IEN2;                                                          \
     96                IEN0 &= STIE_BV;                                                         \
     97                IEN1 &= P0IE_BV;                                                         \
     98                IEN2 &= (P1IE_BV|P2IE_BV);                                               \
     99              )
    100          
    101          // restore interrupt enable registers before sleep
    102          #define HAL_SLEEP_IE_RESTORE( ien0, ien1, ien2 )                               \
    103            st( IEN0 = (ien0);                                                           \
    104                IEN1 = (ien1);                                                           \
    105                IEN2 = (ien2);                                                           \
    106               )
    107          
    108          // convert msec to 625 usec units with round
    109          #define HAL_SLEEP_MS_TO_625US( ms )         (((((uint32) (ms)) * 8) + 4) / 5)
    110          
    111          // convert msec to 32kHz units without round : the ratio of 32 kHz ticks to
    112          // msec ticks is 32768/1000 = 32.768 or 4096/125
    113          #define HAL_SLEEP_MS_TO_32KHZ( ms )         ((((uint32) (ms)) * 4096) / 125)
    114          
    115          // max allowed sleep time in ms
    116          // Note: When OSAL timer was updated to 32 bits, the call to halSleep was
    117          //       changed to take a 32-bit osal_timeout value. But since the CC2540
    118          //       previously used a 16 bit ll_McuPrecisionCount, halSleep was modified
    119          //       to limit osal_timeout to 16 bits as well (please see SVN rev. 27618).
    120          //       However, the max value of the 16 bit ll_McuPrecisionCount is about 41s,
    121          //       which is shorter than the max sleep time of 65.535s! So it is possible
    122          //       Timer2 rollover could occur during sleep, which could affect when an
    123          //       OSAL timer event is generated. The OSAL timer software should
    124          //       be updated to use the full 24bit value of Timer2, allowing timer
    125          //       events of up to 2.9 hours, but until this can be done properly, the
    126          //       max sleep duration will be limited to less than ll_McuPrecisionCount.
    127          // Note: Not an issue for BLE as the max sleep time would have to be less
    128          //       than 32s.
    129          #define MAX_SLEEP_TIMEOUT                   40000
    130          
    131          /*******************************************************************************
    132           * CONSTANTS
    133           */
    134          
    135          // POWER CONSERVATION DEFINITIONS
    136          // Sleep mode H/W definitions (enabled with POWER_SAVING compile option).
    137          #define CC2540_PM0                          0                     // PM0, Clock oscillators on, voltage regulator on
    138          #define CC2540_PM1                          1                     // PM1, 32.768 kHz oscillators on, voltage regulator on
    139          #define CC2540_PM2                          2                     // PM2, 32.768 kHz oscillators on, voltage regulator off
    140          #define CC2540_PM3                          3                     // PM3, All clock oscillators off, voltage regulator off
    141          
    142          // HAL power management mode is set according to the power management state.
    143          // The default setting is HAL_SLEEP_OFF. The actual value is tailored to
    144          // different HW platform. Both HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections
    145          // will turn off the system clock, and halt the MCU. HAL_SLEEP_TIMER can be
    146          // woken up by sleep timer interrupt, I/O interrupt and reset. HAL_SLEEP_DEEP
    147          // can be woken up by I/O interrupt and reset.
    148          #define HAL_SLEEP_OFF                       CC2540_PM0
    149          #define HAL_SLEEP_TIMER                     CC2540_PM2
    150          #define HAL_SLEEP_DEEP                      CC2540_PM3
    151          
    152          // MAX_SLEEP_TIME calculation:
    153          // Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
    154          // Round it to 510 seconds or 510000 ms×î´óË¯ÃßÊ±¼äÊÇ510000ms¡£
    155          #define MAX_SLEEP_TIME                      16711680 //0xFFFF7F=1677087  // max time to sleep allowed by ST, in 32kHz ticks
    156          
    157          // Minimum time to sleep:
    158          // 1. avoid thrashing in-and-out of sleep with short OSAL timer
    159          // 2. define minimum safe sleep period
    160          #if !defined (PM_MIN_SLEEP_TIME)
    161          #define PM_MIN_SLEEP_TIME                   66                    // default to min safe sleep time, in 32kHz ticks
    162          #endif // !PM_MIN_SLEEP_TIME
    163          
    164          // This value is used to adjust the sleep timer compare value such that the
    165          // sleep timer compare takes into account the amount of processing time spent in
    166          // function halSleep(). The first value is determined by measuring the number of
    167          // sleep timer ticks from the beginning of the function to entering sleep mode.
    168          // The second value is determined by measuring the number of sleep timer ticks
    169          // from exit of sleep mode to the call to osal_adjust_timers().
    170          #if defined( CC2541) || defined( CC2541S )
    171          #define HAL_SLEEP_ADJ_TICKS                 25                    // default sleep adjustment, in 32kHz ticks
    172          #else // CC2540
    173          #define HAL_SLEEP_ADJ_TICKS                 35                    // default sleep adjustment, in 32kHz ticks
    174          #endif // CC2541 || CC2541S
    175          
    176          // sleep and external interrupt port masks
    177          #define STIE_BV                             BV(5)
    178          #define P0IE_BV                             BV(5)
    179          #define P1IE_BV                             BV(4)
    180          #define P2IE_BV                             BV(1)
    181          
    182          // for optimized indexing of uint32
    183          #if HAL_MCU_LITTLE_ENDIAN()
    184          #define UINT32_NDX0                         0
    185          #define UINT32_NDX1                         1
    186          #define UINT32_NDX2                         2
    187          #define UINT32_NDX3                         3
    188          #else
    189          #define UINT32_NDX0                         3
    190          #define UINT32_NDX1                         2
    191          #define UINT32_NDX2                         1
    192          #define UINT32_NDX3                         0
    193          #endif // HAL_MCU_LITTLE_ENDIAN()
    194          
    195          /*******************************************************************************
    196           * TYPEDEFS
    197           */
    198          
    199          /*******************************************************************************
    200           * LOCAL VARIABLES
    201           */
    202          
    203          // HAL power management mode is set according to the power management state.
    204          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
    205          
    206          // Flag to indicate if wake is due to impending radio event.
    207          static uint8 wakeForRF;
    208          
    209          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    210          static bool halSleepInt = FALSE;
    211          #endif // HAL_SLEEP_DEBUG_POWER_MODE
    212          
    213          /*******************************************************************************
    214           * GLOBAL VARIABLES
    215           */
    216          
    217          // PCON register value to program when setting power mode
    218          volatile __data uint8 halSleepPconValue = PCON_IDLE;
    219          
    220          /*******************************************************************************
    221           * Prototypes
    222           */
    223          
    224          // The PCON instruction must be 4-byte aligned. The following code may cause
    225          // excessive power consumption if not aligned. See linker file ".xcl" for
    226          // actual placement.
    227          #pragma location = "SLEEP_CODE"
    228          void halSetSleepMode(void);
    229          
    230          void   halSleepSetTimer( uint32 sleepTime, uint32 timeout );
    231          uint32 halSleepReadTimer( void );
    232          uint32 TimerElapsed( void );
    233          
    234          /*******************************************************************************
    235           * @fn          halSleep
    236           *
    237           * @brief       This function put the CC2540 to sleep. The PCON instruction must
    238           *              be 4-byte aligned. The following code may cause excessive power
    239           *              consumption if not aligned. See linker file ".xcl" for actual
    240           *              placement.
    241           *
    242           * input parameters
    243           *
    244           * @param       None.
    245           *
    246           * output parameters
    247           *
    248           * @param       None.
    249           *
    250           * @return      None.
    251           */
    252          #pragma optimize=none
    253          void halSetSleepMode(void)
    254          {
    255            // WARNING: DO NOT ADD ANY ADDITIONAL CODE; THIS IS A FIXED SIZED SEGMENT!
    256            PCON = halSleepPconValue;
    257            // Disallow waking ISR from running in order to give the highest priority to LL_PowerOnReq().
    258            HAL_DISABLE_INTERRUPTS();
    259          }
    260          
    261          /*******************************************************************************
    262           * @fn          halSleep
    263           *
    264           * @brief       This function is called from the OSAL task loop using and
    265           *              existing OSAL interface.  It sets the low power mode of the LL
    266           *              and the CC2540.
    267           *
    268           * input parameters
    269           *
    270           * @param       osal_timeout - Next OSAL timer timeout, in msec.
    271           *
    272           * output parameters
    273           *
    274           * @param       None.
    275           *
    276           * @return      None.
    277           */
    278          void halSleep( uint32 osal_timeout )
    279          {
    280            uint32 timeout;
    281            uint32 llTimeout;
    282            uint32 sleepTimer;
    283          
    284          #ifdef DEBUG_GPIO
    285            // TEMP
    286            P1_0 = 1;
    287          #endif // DEBUG_GPIO
    288            
    289            
    290            
    291          
    292            // max allowed sleep time in ms
    293            if (osal_timeout > MAX_SLEEP_TIMEOUT)
    294            {
    295              osal_timeout = MAX_SLEEP_TIMEOUT;
    296            }
    297          
    298            // get LL timeout value already converted to 32kHz ticks
    299            LL_TimeToNextRfEvent( &sleepTimer, &llTimeout );
    300          
    301            // check if no OSAL timeout
    302            // Note: If the next wake event is due to an OSAL timeout, then wakeForRF
    303            //       will already be FALSE, and the call to LL_TimeToNExtRfEvent will
    304            //       already have taken a snapshot of the Sleep Timer.
    305            if (osal_timeout == 0)
    306            {
    307              // use common variable
    308              timeout = llTimeout;
    309          
    310              // check if there's time before the next radio event
    311              // Note: Since the OSAL timeout is zero, then if the radio timeout is
    312              //       not zero, the next wake (if one) will be due to the radio event.
    313              wakeForRF = (timeout != 0) ? TRUE : FALSE;
    314            }
    315            else // OSAL timeout is non-zero
    316            {
    317              // convet OSAL timeout to sleep time
    318              // Note: Could be early by one 32kHz timer tick due to rounding.
    319              timeout = HAL_SLEEP_MS_TO_32KHZ( osal_timeout );
    320          
    321              // so check time to radio event is non-zero, and if so, use shorter value
    322              if ((llTimeout != 0) && (llTimeout < timeout))
    323              {
    324                // use common variable
    325                timeout = llTimeout;
    326          
    327                // the next ST wake time is due to radio
    328                wakeForRF = TRUE;
    329              }
    330              else // OSAL timeout will be used to wake
    331              {
    332                // so take a snapshot of the sleep timer for sleep based on OSAL timeout
    333                sleepTimer = halSleepReadTimer();
    334          
    335                // the next ST wake time is not due to radio
    336                wakeForRF = FALSE;
    337              }
    338            }
    339          
    340            // HAL_SLEEP_PM3 is entered only if the timeout is zero//Èç¹ûtimeout =0 ½øÈëÉî¶ÈË¯Ãß£¬·ñÔò½øÈëÇ³Ë¯Ãß
    341            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
    342            
    343           // HalLcdWriteStringValue("halPwrMgtMode:",halPwrMgtMode, 10, HAL_LCD_LINE_4); 
    344          #ifdef DEBUG_GPIO
    345            // TEMP
    346            P1_0 = 0;
    347          #endif // DEBUG_GPIO
    348          
    349            // check if sleep should be entered
    350            if ( (timeout > PM_MIN_SLEEP_TIME) || (timeout == 0) )
    351            {
    352              halIntState_t ien0, ien1, ien2;
    353          
    354          #ifdef DEBUG_GPIO
    355              // TEMP
    356              P1_0 = 1;
    357          #endif // DEBUG_GPIO
    358          
    359              HAL_ASSERT( HAL_INTERRUPTS_ARE_ENABLED() );
    360              HAL_DISABLE_INTERRUPTS();
    361          
    362              // check if radio allows sleep, and if so, preps system for shutdown
    363              if ( halSleepPconValue && ( LL_PowerOffReq(halPwrMgtMode) == LL_SLEEP_REQUEST_ALLOWED ) )
    364              {
    365          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    366                // get peripherals ready for sleep //¹Ø±ÕÍâÉè£¬½øÈëË¯Ãß£¬´Ë´¦º¯ÊýÎª¿Õ
    367          
    368                HalKeyEnterSleep();
    369          #endif // ((defined HAL_KEY) && (HAL_KEY == TRUE))
    370          
    371          #ifdef HAL_SLEEP_DEBUG_LED
    372                HAL_TURN_OFF_LED3();
    373          #else
    374                // use this to turn LEDs off during sleep//¹Ø±ÕLEDµÆ£¬½øÈëË¯Ãß
    375                HalLedEnterSleep();
    376          #endif // HAL_SLEEP_DEBUG_LED
    377          
    378                // enable sleep timer interrupt//Æô¶¯Ë¯Ãß¶¨Ê±Æ÷ÖÐ¶Ï
    379          
    380                if (timeout != 0)
    381                {
    382                  // check if the time to next wake event is greater than max sleep time
    383                  if (timeout > MAX_SLEEP_TIME )
    384                  {
    385                    // it is, so limit to max allowed sleep time (~510s)//ÉèÖÃË¯Ãß¶¨Ê±Æ÷Ê±¼ä
    386                    halSleepSetTimer( sleepTimer, MAX_SLEEP_TIME );
    387                  }
    388                  else // not more than allowed sleep time
    389                  {
    390                    // so set sleep time to actual amount
    391                    halSleepSetTimer( sleepTimer, timeout );
    392                  // HalLcdWriteStringValue("timeout:",timeout, 10, HAL_LCD_LINE_6); 
    393                  }
    394                }
    395          
    396                // prep CC254x power mode
    397                HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);//ÉèÖÃSLEEP.MODE=halPwrMgtMode,PCON.IDLE=1
    398          
    399                // save interrupt enable registers and disable all interrupts
    400                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
    401                HAL_ENABLE_INTERRUPTS();
    402          
    403          #ifdef DEBUG_GPIO
    404                // TEMP
    405                P1_0 = 0;
    406          #endif // DEBUG_GPIO
    407          
    408                // set CC254x power mode; interrupts are disabled after this function
    409                // Note: Any ISR that could wake the device from sleep needs to use
    410                //       CLEAR_SLEEP_MODE(), which will clear the halSleepPconValue flag
    411                //       used to enter sleep mode, thereby preventing the device from
    412                //       missing this interrupt.
    413                HAL_SLEEP_SET_POWER_MODE();
    414          
    415          #ifdef DEBUG_GPIO
    416                // TEMP
    417                P1_0 = 1;
    418          #endif // DEBUG_GPIO
    419          
    420                // check if ST interrupt pending, and if not, clear wakeForRF flag
    421                // Note: This is needed in case we are not woken by the sleep timer but
    422                //       by for example a key press. In this case, the flag has to be
    423                //       cleared as we are not just before a radio event.
    424                // Note: There is the possiblity that we may wake from an interrupt just
    425                //       before the sleep timer would have woken us just before a radio
    426                //       event, in which case power will be wasted as we will probably
    427                //       enter this routine one or more times before the radio event.
    428                //       However, this is presumably unusual, and isn't expected to have
    429                //       much impact on average power consumption.
    430                if ( (wakeForRF == TRUE) && !(IRCON & 0x80) )
    431                {
    432                  wakeForRF = FALSE;
    433                }
    434          
    435                // restore interrupt enable registers
    436                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
    437          
    438                // power on the LL; blocks until completion
    439                // Note: This is done here to ensure the 32MHz XOSC has stablized, in
    440                //       case it is needed (e.g. the ADC is used by the joystick).
    441                LL_PowerOnReq( (halPwrMgtMode == CC2540_PM3), wakeForRF );
    442          
    443          #ifdef HAL_SLEEP_DEBUG_LED
    444                HAL_TURN_ON_LED3();
    445          #else //!HAL_SLEEP_DEBUG_LED
    446                // use this to turn LEDs back on after sleep
    447                HalLedExitSleep();
    448          #endif // HAL_SLEEP_DEBUG_LED
    449          
    450          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    451                // handle peripherals
    452                (void)HalKeyExitSleep();//Èç¹ûÓÐ°´¼ü°´ÏÂ£¬Ìø³öË¯ÃßÄ£Ê½£¬Ê¹ÄÜËùÓÐÖÐ¶Ï
    453          #endif // ((defined HAL_KEY) && (HAL_KEY == TRUE))
    454              }
    455          
    456              HAL_ENABLE_INTERRUPTS();
    457            }
    458          
    459          #ifdef DEBUG_GPIO
    460                // TEMP
    461                P1_0 = 0;
    462          #endif // DEBUG_GPIO
    463          
    464            return;
    465          }
    466          
    467          
    468          /*******************************************************************************
    469           * @fn          halSleepSetTimer
    470           *
    471           * @brief       This function sets the CC2540 sleep timer compare value based
    472           *              on a given snapshot of the sleep timer, and a timeout that is
    473           *              relative to that snapshot. The snapshot is provided as it may
    474           *              need to be taken as close to the snapshot of Timer 2 (the radio
    475           *              timer) as possible so that the time to the next radio event,
    476           *              when converted to 32kHz ticks, is as accurate as possible in
    477           *              terms of sleep time. In addition, the offset is adjusted based
    478           *              on a configurable adjustment to take the sleep handler's
    479           *              execution time into account. The sleep timer interrupt is then
    480           *              setup for wake.
    481           *
    482           * input parameters
    483           *
    484           * @param       sleepTimer - Sleep timer value timeout is relative to.
    485           * @param       timeout    - Timeout value in 32kHz units.
    486           *
    487           * output parameters
    488           *
    489           * @param       None.
    490           *
    491           * @return      None.
    492           */
    493          void halSleepSetTimer( uint32 sleepTimer, uint32 timeout )
    494          {
    495            HAL_SLEEP_TIMER_DISABLE_INT();
    496          
    497            // compute sleep timer compare value
    498            sleepTimer += timeout;
    499          
    500            // subtract the processing time spent in function halSleep()
    501            sleepTimer -= HAL_SLEEP_ADJ_TICKS;
    502          
    503            // set sleep timer compare; ST0 must be written last
    504            ST2 = ((uint8 *)&sleepTimer)[UINT32_NDX2];
    505            ST1 = ((uint8 *)&sleepTimer)[UINT32_NDX1];
    506            ST0 = ((uint8 *)&sleepTimer)[UINT32_NDX0];
    507          
    508            HAL_SLEEP_TIMER_CLEAR_INT();
    509            HAL_SLEEP_TIMER_ENABLE_INT();
    510          
    511            return;
    512          }
    513          
    514          
    515          /*******************************************************************************
    516           * @fn          halSleepReadTimer
    517           *
    518           * @brief       This function reads the CC2540 sleep timer.
    519           *
    520           * input parameters
    521           *
    522           * @param       None.
    523           *
    524           * output parameters
    525           *
    526           * @param       None.
    527           *
    528           * @return      A snapshot of the 24 bit sleep timer.
    529           */
    530          uint32 halSleepReadTimer( void )
    531          {
    532            uint32 sleepTimer;
    533          
    534            // read the sleep timer
    535            // Note: Read of ST0 latches ST1 and ST2.
    536            ((uint8 *)&sleepTimer)[UINT32_NDX0] = ST0;
    537            ((uint8 *)&sleepTimer)[UINT32_NDX1] = ST1;
    538            ((uint8 *)&sleepTimer)[UINT32_NDX2] = ST2;
    539            ((uint8 *)&sleepTimer)[UINT32_NDX3] = 0;
    540          
    541            return( sleepTimer );
    542          }
    543          
    544          
    545          /*******************************************************************************
    546           * @fn          TimerElapsed
    547           *
    548           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    549           *
    550           * input parameters
    551           *
    552           * @param       None.
    553           *
    554           * output parameters
    555           *
    556           * @param       None.
    557           *
    558           * @return      Number of timer ticks elapsed during sleep.
    559           */
    560          uint32 TimerElapsed( void )
    561          {
    562            return( 0 );
    563          }
    564          
    565          
    566          /*******************************************************************************
    567           * @fn          halRestoreSleepLevel
    568           *
    569           * @brief       Restore the deepest timer sleep level.
    570           *
    571           * input parameters
    572           *
    573           * @param       None
    574           *
    575           * output parameters
    576           *
    577           * @param       None.
    578           *
    579           * @return      None.
    580           */
    581          void halRestoreSleepLevel( void )
    582          {
    583            // Stub
    584          #ifdef PM_TEST
    585            osal_start_timerEx (Hal_TaskID, HAL_SLEEP_TIMER_EVENT, 1000);
    586          #endif // PM_TEST
    587          }
    588          
    589          
    590          /*******************************************************************************
    591           * @fn          halSleepTimerIsr
    592           *
    593           * @brief       Sleep timer ISR.
    594           *
    595           * input parameters
    596           *
    597           * None.
    598           *
    599           * output parameters
    600           *
    601           * @param       None.
    602           *
    603           * @return      None.
    604           */
    605          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
    606          {
    607            HAL_ENTER_ISR();
    608          
    609            HAL_SLEEP_TIMER_CLEAR_INT();
    610          
    611          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    612            halSleepInt = TRUE;
    613          #endif // HAL_SLEEP_DEBUG_POWER_MODE
    614          
    615            CLEAR_SLEEP_MODE();
    616          
    617            HAL_EXIT_ISR();
    618          
    619            return;
    620          }
    621          
    622          /*******************************************************************************
    623           */
    624          

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      0  TimerElapsed
       0      0      0  halRestoreSleepLevel
       0      0     24  halSetSleepMode
       0      0     28  halSleep
                          0 0 24 -> HalKeyEnterSleep
                          0 0 24 -> HalKeyExitSleep
                          0 0 24 -> LL_PowerOffReq
                          0 0 24 -> LL_PowerOnReq
                          0 0 24 -> LL_TimeToNextRfEvent
                          0 0 24 -> halSetSleepMode
                          0 0 24 -> halSleepReadTimer
                          0 0 28 -> halSleepSetTimer
       3      0     28  halSleepReadTimer
       0      0     44  halSleepSetTimer
       4      0      0  halSleepTimerIsr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for halSleepPconValue>
       6  ??TimerElapsed?relay
       6  ??halRestoreSleepLevel?relay
       6  ??halSetSleepMode?relay
       6  ??halSleep?relay
       6  ??halSleepReadTimer?relay
       6  ??halSleepSetTimer?relay
       3  ??halSleepTimerIsr??INTVEC 43
       9  ?Subroutine0
       1  IEN2
       1  PCON
       1  SLEEPCMD
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
      11  TimerElapsed
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       1  _A_P1
       4  __Constant_43
       4  __Constant_7d
       4  __Constant_9c41
       4  __Constant_ff0000
       4  __Constant_ff0001
       4  __Constant_ffffffe7
       1  halPwrMgtMode
       3  halRestoreSleepLevel
       8  halSetSleepMode
     400  halSleep
       1  halSleepPconValue
      70  halSleepReadTimer
      97  halSleepSetTimer
      36  halSleepTimerIsr
       1  wakeForRF

 
 590 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   1 byte  in segment DATA_I
   1 byte  in segment DATA_ID
   3 bytes in segment INTVEC
  36 bytes in segment NEAR_CODE
  11 bytes in segment SFR_AN
   8 bytes in segment SLEEP_CODE
  24 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 671 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of CONST memory (+ 24 bytes shared)
   1 byte  of DATA  memory (+ 11 bytes shared)
   2 bytes of XDATA memory

Errors: none
Warnings: none
