###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             28/Feb/2014  16:48:34 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Components\ha #
#                          l\target\CC2540EB\hal_sleep.c                      #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\config\b #
#                          uildComponents.cfg (-DBROADCASTER_CFG=0x01         #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheralzeke\CC2541DB\buildCo #
#                          nfig.cfg (-DHOST_CONFIG=PERIPHERAL_CFG             #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Components\ha #
#                          l\target\CC2540EB\hal_sleep.c -D                   #
#                          INT_HEAP_LEN=3074 -D HALNODEBUG -D                 #
#                          OSAL_CBTIMER_NUM_TASKS=1 -D HAL_AES_DMA=TRUE -D    #
#                          HAL_DMA=TRUE -D POWER_SAVING -D xPLUS_BROADCASTER  #
#                          -D HAL_LCD=TRUE -D HAL_LED=TRUE -D HAL_UART=TRUE   #
#                          -lcN E:\TexasInstruments\BLE-CC254x-1.4.0\Projects #
#                          \ble\SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\ #
#                           -o E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\   #
#                          -e --debug --core=plain --dptr=16,1                #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\common\  #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\include\ #
#                           -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\C #
#                          omponents\hal\include\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\hal\target\CC2541EB\ -I                      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\osal\include\ -I E:\TexasInstruments\BLE-CC2 #
#                          54x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2 #
#                          541DB\..\..\..\..\Components\services\saddr\ -I    #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\include\ -I E:\TexasInstruments\BLE-CC25 #
#                          4x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC25 #
#                          41DB\..\..\..\..\Components\ble\controller\phy\    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Co #
#                          mponents\ble\controller\include\ -I                #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\..\..\Components\ble\host\ -I               #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\common\cc25 #
#                          40\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\comm #
#                          on\npi\npi_np\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\Profiles\Roles\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Si #
#                          mpleProfile\ -I E:\TexasInstruments\BLE-CC254x-1.4 #
#                          .0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB\. #
#                          .\..\Profiles\DevInfo\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Ba #
#                          tt\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\Prof #
#                          iles\HIDDev\ -Ohz                                  #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\hal_s #
#                          leep.lst                                           #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\hal_sl #
#                          eep.r51                                            #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Components\hal\target\CC2540EB\hal_sleep.c
      1          /*******************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2013-07-26 10:28:58 -0700 (Fri, 26 Jul 2013) $
      4            Revision:       $Revision: 34783 $
      5          
      6            Description:    This module contains the HAL power management procedures for
      7                            the CC2540.
      8          
      9            Copyright 2006-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          *******************************************************************************/
     39          
     40          /*******************************************************************************
     41           * INCLUDES
     42           */
     43          #include "hal_types.h"
     44          #include "hal_mcu.h"
     45          #include "hal_board.h"
     46          #include "hal_sleep.h"
     47          #include "hal_led.h"
     48          #include "hal_key.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Timers.h"
     51          #include "OSAL_Tasks.h"
     52          #include "OSAL_PwrMgr.h"
     53          #include "hal_drivers.h"
     54          #include "hal_assert.h"
     55          #include "ll_sleep.h"
     56          #include "ll_timer2.h"
     57          #include "ll_math.h"
     58          
     59          /*******************************************************************************
     60           * MACROS
     61           */
     62          
     63          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
     64          // Set CC2540 power mode; always use PM2.
     65          #define HAL_SLEEP_PREP_POWER_MODE(mode)                                        \
     66            st( SLEEPCMD &= ~PMODE; /* clear mode bits */                                \
     67                SLEEPCMD |= mode;   /* set mode bits   */                                \
     68                while (!(STLOAD & LDRDY));                                               \
     69                halSleepPconValue = PCON_IDLE;                                           \
     70              )
     71          #define HAL_SLEEP_SET_POWER_MODE()                                             \
     72            halSetSleepMode()
     73          
     74          #else // HAL_SLEEP_DEBUG_POWER_MODE
     75          
     76          // Debug: Don't set power mode, just block until sleep timer interrupt.
     77          #define HAL_SLEEP_PREP_POWER_MODE(mode)     /* nothing */
     78          #define HAL_SLEEP_SET_POWER_MODE()                                             \
     79            st( while(halSleepInt == FALSE);                                             \
     80                halSleepInt = FALSE;                                                     \
     81                HAL_DISABLE_INTERRUPTS();                                                \
     82              )
     83          #endif // !HAL_SLEEP_DEBUG_POWER_MODE
     84          
     85          // sleep timer interrupt control
     86          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)  // enable sleep timer interrupt
     87          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;) // disable sleep timer interrupt
     88          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(IRCON &= ~0x80;)   // clear sleep interrupt flag
     89          
     90          // backup interrupt enable registers before sleep
     91          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE( ien0, ien1, ien2 )                    \
     92            st( (ien0)  = IEN0;                                                          \
     93                (ien1)  = IEN1;                                                          \
     94                (ien2)  = IEN2;                                                          \
     95                IEN0 &= STIE_BV;                                                         \
     96                IEN1 &= P0IE_BV;                                                         \
     97                IEN2 &= (P1IE_BV|P2IE_BV);                                               \
     98              )
     99          
    100          // restore interrupt enable registers before sleep
    101          #define HAL_SLEEP_IE_RESTORE( ien0, ien1, ien2 )                               \
    102            st( IEN0 = (ien0);                                                           \
    103                IEN1 = (ien1);                                                           \
    104                IEN2 = (ien2);                                                           \
    105               )
    106          
    107          // convert msec to 625 usec units with round
    108          #define HAL_SLEEP_MS_TO_625US( ms )         (((((uint32) (ms)) * 8) + 4) / 5)
    109          
    110          // convert msec to 32kHz units without round : the ratio of 32 kHz ticks to
    111          // msec ticks is 32768/1000 = 32.768 or 4096/125
    112          #define HAL_SLEEP_MS_TO_32KHZ( ms )         ((((uint32) (ms)) * 4096) / 125)
    113          
    114          // max allowed sleep time in ms
    115          // Note: When OSAL timer was updated to 32 bits, the call to halSleep was
    116          //       changed to take a 32-bit osal_timeout value. But since the CC2540
    117          //       previously used a 16 bit ll_McuPrecisionCount, halSleep was modified
    118          //       to limit osal_timeout to 16 bits as well (please see SVN rev. 27618).
    119          //       However, the max value of the 16 bit ll_McuPrecisionCount is about 41s,
    120          //       which is shorter than the max sleep time of 65.535s! So it is possible
    121          //       Timer2 rollover could occur during sleep, which could affect when an
    122          //       OSAL timer event is generated. The OSAL timer software should
    123          //       be updated to use the full 24bit value of Timer2, allowing timer
    124          //       events of up to 2.9 hours, but until this can be done properly, the
    125          //       max sleep duration will be limited to less than ll_McuPrecisionCount.
    126          // Note: Not an issue for BLE as the max sleep time would have to be less
    127          //       than 32s.
    128          #define MAX_SLEEP_TIMEOUT                   40000
    129          
    130          /*******************************************************************************
    131           * CONSTANTS
    132           */
    133          
    134          // POWER CONSERVATION DEFINITIONS
    135          // Sleep mode H/W definitions (enabled with POWER_SAVING compile option).
    136          #define CC2540_PM0                          0                     // PM0, Clock oscillators on, voltage regulator on
    137          #define CC2540_PM1                          1                     // PM1, 32.768 kHz oscillators on, voltage regulator on
    138          #define CC2540_PM2                          2                     // PM2, 32.768 kHz oscillators on, voltage regulator off
    139          #define CC2540_PM3                          3                     // PM3, All clock oscillators off, voltage regulator off
    140          
    141          // HAL power management mode is set according to the power management state.
    142          // The default setting is HAL_SLEEP_OFF. The actual value is tailored to
    143          // different HW platform. Both HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections
    144          // will turn off the system clock, and halt the MCU. HAL_SLEEP_TIMER can be
    145          // woken up by sleep timer interrupt, I/O interrupt and reset. HAL_SLEEP_DEEP
    146          // can be woken up by I/O interrupt and reset.
    147          #define HAL_SLEEP_OFF                       CC2540_PM0
    148          #define HAL_SLEEP_TIMER                     CC2540_PM2
    149          #define HAL_SLEEP_DEEP                      CC2540_PM3
    150          
    151          // MAX_SLEEP_TIME calculation:
    152          // Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
    153          // Round it to 510 seconds or 510000 ms
    154          #define MAX_SLEEP_TIME                      16711680              // max time to sleep allowed by ST, in 32kHz ticks
    155          
    156          // Minimum time to sleep:
    157          // 1. avoid thrashing in-and-out of sleep with short OSAL timer
    158          // 2. define minimum safe sleep period
    159          #if !defined (PM_MIN_SLEEP_TIME)
    160          #define PM_MIN_SLEEP_TIME                   66                    // default to min safe sleep time, in 32kHz ticks
    161          #endif // !PM_MIN_SLEEP_TIME
    162          
    163          // This value is used to adjust the sleep timer compare value such that the
    164          // sleep timer compare takes into account the amount of processing time spent in
    165          // function halSleep(). The first value is determined by measuring the number of
    166          // sleep timer ticks from the beginning of the function to entering sleep mode.
    167          // The second value is determined by measuring the number of sleep timer ticks
    168          // from exit of sleep mode to the call to osal_adjust_timers().
    169          #if defined( CC2541) || defined( CC2541S )
    170          #define HAL_SLEEP_ADJ_TICKS                 25                    // default sleep adjustment, in 32kHz ticks
    171          #else // CC2540
    172          #define HAL_SLEEP_ADJ_TICKS                 35                    // default sleep adjustment, in 32kHz ticks
    173          #endif // CC2541 || CC2541S
    174          
    175          // sleep and external interrupt port masks
    176          #define STIE_BV                             BV(5)
    177          #define P0IE_BV                             BV(5)
    178          #define P1IE_BV                             BV(4)
    179          #define P2IE_BV                             BV(1)
    180          
    181          // for optimized indexing of uint32
    182          #if HAL_MCU_LITTLE_ENDIAN()
    183          #define UINT32_NDX0                         0
    184          #define UINT32_NDX1                         1
    185          #define UINT32_NDX2                         2
    186          #define UINT32_NDX3                         3
    187          #else
    188          #define UINT32_NDX0                         3
    189          #define UINT32_NDX1                         2
    190          #define UINT32_NDX2                         1
    191          #define UINT32_NDX3                         0
    192          #endif // HAL_MCU_LITTLE_ENDIAN()
    193          
    194          /*******************************************************************************
    195           * TYPEDEFS
    196           */
    197          
    198          /*******************************************************************************
    199           * LOCAL VARIABLES
    200           */
    201          
    202          // HAL power management mode is set according to the power management state.
    203          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
    204          
    205          // Flag to indicate if wake is due to impending radio event.
    206          static uint8 wakeForRF;
    207          
    208          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    209          static bool halSleepInt = FALSE;
    210          #endif // HAL_SLEEP_DEBUG_POWER_MODE
    211          
    212          /*******************************************************************************
    213           * GLOBAL VARIABLES
    214           */
    215          
    216          // PCON register value to program when setting power mode
    217          volatile __data uint8 halSleepPconValue = PCON_IDLE;
    218          
    219          /*******************************************************************************
    220           * Prototypes
    221           */
    222          
    223          // The PCON instruction must be 4-byte aligned. The following code may cause
    224          // excessive power consumption if not aligned. See linker file ".xcl" for
    225          // actual placement.
    226          #pragma location = "SLEEP_CODE"
    227          void halSetSleepMode(void);
    228          
    229          void   halSleepSetTimer( uint32 sleepTime, uint32 timeout );
    230          uint32 halSleepReadTimer( void );
    231          uint32 TimerElapsed( void );
    232          
    233          /*******************************************************************************
    234           * @fn          halSleep
    235           *
    236           * @brief       This function put the CC2540 to sleep. The PCON instruction must
    237           *              be 4-byte aligned. The following code may cause excessive power
    238           *              consumption if not aligned. See linker file ".xcl" for actual
    239           *              placement.
    240           *
    241           * input parameters
    242           *
    243           * @param       None.
    244           *
    245           * output parameters
    246           *
    247           * @param       None.
    248           *
    249           * @return      None.
    250           */
    251          #pragma optimize=none
    252          void halSetSleepMode(void)
    253          {
    254            // WARNING: DO NOT ADD ANY ADDITIONAL CODE; THIS IS A FIXED SIZED SEGMENT!
    255            PCON = halSleepPconValue;
    256            // Disallow waking ISR from running in order to give the highest priority to LL_PowerOnReq().
    257            HAL_DISABLE_INTERRUPTS();
    258          }
    259          
    260          /*******************************************************************************
    261           * @fn          halSleep
    262           *
    263           * @brief       This function is called from the OSAL task loop using and
    264           *              existing OSAL interface.  It sets the low power mode of the LL
    265           *              and the CC2540.
    266           *
    267           * input parameters
    268           *
    269           * @param       osal_timeout - Next OSAL timer timeout, in msec.
    270           *
    271           * output parameters
    272           *
    273           * @param       None.
    274           *
    275           * @return      None.
    276           */
    277          void halSleep( uint32 osal_timeout )
    278          {
    279            uint32 timeout;
    280            uint32 llTimeout;
    281            uint32 sleepTimer;
    282          
    283          #ifdef DEBUG_GPIO
    284            // TEMP
    285            P1_0 = 1;
    286          #endif // DEBUG_GPIO
    287          
    288            // max allowed sleep time in ms
    289            if (osal_timeout > MAX_SLEEP_TIMEOUT)
    290            {
    291              osal_timeout = MAX_SLEEP_TIMEOUT;
    292            }
    293          
    294            // get LL timeout value already converted to 32kHz ticks
    295            LL_TimeToNextRfEvent( &sleepTimer, &llTimeout );
    296          
    297            // check if no OSAL timeout
    298            // Note: If the next wake event is due to an OSAL timeout, then wakeForRF
    299            //       will already be FALSE, and the call to LL_TimeToNExtRfEvent will
    300            //       already have taken a snapshot of the Sleep Timer.
    301            if (osal_timeout == 0)
    302            {
    303              // use common variable
    304              timeout = llTimeout;
    305          
    306              // check if there's time before the next radio event
    307              // Note: Since the OSAL timeout is zero, then if the radio timeout is
    308              //       not zero, the next wake (if one) will be due to the radio event.
    309              wakeForRF = (timeout != 0) ? TRUE : FALSE;
    310            }
    311            else // OSAL timeout is non-zero
    312            {
    313              // convet OSAL timeout to sleep time
    314              // Note: Could be early by one 32kHz timer tick due to rounding.
    315              timeout = HAL_SLEEP_MS_TO_32KHZ( osal_timeout );
    316          
    317              // so check time to radio event is non-zero, and if so, use shorter value
    318              if ((llTimeout != 0) && (llTimeout < timeout))
    319              {
    320                // use common variable
    321                timeout = llTimeout;
    322          
    323                // the next ST wake time is due to radio
    324                wakeForRF = TRUE;
    325              }
    326              else // OSAL timeout will be used to wake
    327              {
    328                // so take a snapshot of the sleep timer for sleep based on OSAL timeout
    329                sleepTimer = halSleepReadTimer();
    330          
    331                // the next ST wake time is not due to radio
    332                wakeForRF = FALSE;
    333              }
    334            }
    335          
    336            // HAL_SLEEP_PM3 is entered only if the timeout is zero
    337            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
    338          
    339          #ifdef DEBUG_GPIO
    340            // TEMP
    341            P1_0 = 0;
    342          #endif // DEBUG_GPIO
    343          
    344            // check if sleep should be entered
    345            if ( (timeout > PM_MIN_SLEEP_TIME) || (timeout == 0) )
    346            {
    347              halIntState_t ien0, ien1, ien2;
    348          
    349          #ifdef DEBUG_GPIO
    350              // TEMP
    351              P1_0 = 1;
    352          #endif // DEBUG_GPIO
    353          
    354              HAL_ASSERT( HAL_INTERRUPTS_ARE_ENABLED() );
    355              HAL_DISABLE_INTERRUPTS();
    356          
    357              // check if radio allows sleep, and if so, preps system for shutdown
    358              if ( halSleepPconValue && ( LL_PowerOffReq(halPwrMgtMode) == LL_SLEEP_REQUEST_ALLOWED ) )
    359              {
    360          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    361                // get peripherals ready for sleep
    362                HalKeyEnterSleep();
    363          #endif // ((defined HAL_KEY) && (HAL_KEY == TRUE))
    364          
    365          #ifdef HAL_SLEEP_DEBUG_LED
    366                HAL_TURN_OFF_LED3();
    367          #else
    368                // use this to turn LEDs off during sleep
    369                HalLedEnterSleep();
    370          #endif // HAL_SLEEP_DEBUG_LED
    371          
    372                // enable sleep timer interrupt
    373                if (timeout != 0)
    374                {
    375                  // check if the time to next wake event is greater than max sleep time
    376                  if (timeout > MAX_SLEEP_TIME )
    377                  {
    378                    // it is, so limit to max allowed sleep time (~510s)
    379                    halSleepSetTimer( sleepTimer, MAX_SLEEP_TIME );
    380                  }
    381                  else // not more than allowed sleep time
    382                  {
    383                    // so set sleep time to actual amount
    384                    halSleepSetTimer( sleepTimer, timeout );
    385                  }
    386                }
    387          
    388                // prep CC254x power mode
    389                HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);
    390          
    391                // save interrupt enable registers and disable all interrupts
    392                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
    393                HAL_ENABLE_INTERRUPTS();
    394          
    395          #ifdef DEBUG_GPIO
    396                // TEMP
    397                P1_0 = 0;
    398          #endif // DEBUG_GPIO
    399          
    400                // set CC254x power mode; interrupts are disabled after this function
    401                // Note: Any ISR that could wake the device from sleep needs to use
    402                //       CLEAR_SLEEP_MODE(), which will clear the halSleepPconValue flag
    403                //       used to enter sleep mode, thereby preventing the device from
    404                //       missing this interrupt.
    405                HAL_SLEEP_SET_POWER_MODE();
    406          
    407          #ifdef DEBUG_GPIO
    408                // TEMP
    409                P1_0 = 1;
    410          #endif // DEBUG_GPIO
    411          
    412                // check if ST interrupt pending, and if not, clear wakeForRF flag
    413                // Note: This is needed in case we are not woken by the sleep timer but
    414                //       by for example a key press. In this case, the flag has to be
    415                //       cleared as we are not just before a radio event.
    416                // Note: There is the possiblity that we may wake from an interrupt just
    417                //       before the sleep timer would have woken us just before a radio
    418                //       event, in which case power will be wasted as we will probably
    419                //       enter this routine one or more times before the radio event.
    420                //       However, this is presumably unusual, and isn't expected to have
    421                //       much impact on average power consumption.
    422                if ( (wakeForRF == TRUE) && !(IRCON & 0x80) )
    423                {
    424                  wakeForRF = FALSE;
    425                }
    426          
    427                // restore interrupt enable registers
    428                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
    429          
    430                // power on the LL; blocks until completion
    431                // Note: This is done here to ensure the 32MHz XOSC has stablized, in
    432                //       case it is needed (e.g. the ADC is used by the joystick).
    433                LL_PowerOnReq( (halPwrMgtMode == CC2540_PM3), wakeForRF );
    434          
    435          #ifdef HAL_SLEEP_DEBUG_LED
    436                HAL_TURN_ON_LED3();
    437          #else //!HAL_SLEEP_DEBUG_LED
    438                // use this to turn LEDs back on after sleep
    439                HalLedExitSleep();
    440          #endif // HAL_SLEEP_DEBUG_LED
    441          
    442          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    443                // handle peripherals
    444                (void)HalKeyExitSleep();
    445          #endif // ((defined HAL_KEY) && (HAL_KEY == TRUE))
    446              }
    447          
    448              HAL_ENABLE_INTERRUPTS();
    449            }
    450          
    451          #ifdef DEBUG_GPIO
    452                // TEMP
    453                P1_0 = 0;
    454          #endif // DEBUG_GPIO
    455          
    456            return;
    457          }
    458          
    459          
    460          /*******************************************************************************
    461           * @fn          halSleepSetTimer
    462           *
    463           * @brief       This function sets the CC2540 sleep timer compare value based
    464           *              on a given snapshot of the sleep timer, and a timeout that is
    465           *              relative to that snapshot. The snapshot is provided as it may
    466           *              need to be taken as close to the snapshot of Timer 2 (the radio
    467           *              timer) as possible so that the time to the next radio event,
    468           *              when converted to 32kHz ticks, is as accurate as possible in
    469           *              terms of sleep time. In addition, the offset is adjusted based
    470           *              on a configurable adjustment to take the sleep handler's
    471           *              execution time into account. The sleep timer interrupt is then
    472           *              setup for wake.
    473           *
    474           * input parameters
    475           *
    476           * @param       sleepTimer - Sleep timer value timeout is relative to.
    477           * @param       timeout    - Timeout value in 32kHz units.
    478           *
    479           * output parameters
    480           *
    481           * @param       None.
    482           *
    483           * @return      None.
    484           */
    485          void halSleepSetTimer( uint32 sleepTimer, uint32 timeout )
    486          {
    487            HAL_SLEEP_TIMER_DISABLE_INT();
    488          
    489            // compute sleep timer compare value
    490            sleepTimer += timeout;
    491          
    492            // subtract the processing time spent in function halSleep()
    493            sleepTimer -= HAL_SLEEP_ADJ_TICKS;
    494          
    495            // set sleep timer compare; ST0 must be written last
    496            ST2 = ((uint8 *)&sleepTimer)[UINT32_NDX2];
    497            ST1 = ((uint8 *)&sleepTimer)[UINT32_NDX1];
    498            ST0 = ((uint8 *)&sleepTimer)[UINT32_NDX0];
    499          
    500            HAL_SLEEP_TIMER_CLEAR_INT();
    501            HAL_SLEEP_TIMER_ENABLE_INT();
    502          
    503            return;
    504          }
    505          
    506          
    507          /*******************************************************************************
    508           * @fn          halSleepReadTimer
    509           *
    510           * @brief       This function reads the CC2540 sleep timer.
    511           *
    512           * input parameters
    513           *
    514           * @param       None.
    515           *
    516           * output parameters
    517           *
    518           * @param       None.
    519           *
    520           * @return      A snapshot of the 24 bit sleep timer.
    521           */
    522          uint32 halSleepReadTimer( void )
    523          {
    524            uint32 sleepTimer;
    525          
    526            // read the sleep timer
    527            // Note: Read of ST0 latches ST1 and ST2.
    528            ((uint8 *)&sleepTimer)[UINT32_NDX0] = ST0;
    529            ((uint8 *)&sleepTimer)[UINT32_NDX1] = ST1;
    530            ((uint8 *)&sleepTimer)[UINT32_NDX2] = ST2;
    531            ((uint8 *)&sleepTimer)[UINT32_NDX3] = 0;
    532          
    533            return( sleepTimer );
    534          }
    535          
    536          
    537          /*******************************************************************************
    538           * @fn          TimerElapsed
    539           *
    540           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    541           *
    542           * input parameters
    543           *
    544           * @param       None.
    545           *
    546           * output parameters
    547           *
    548           * @param       None.
    549           *
    550           * @return      Number of timer ticks elapsed during sleep.
    551           */
    552          uint32 TimerElapsed( void )
    553          {
    554            return( 0 );
    555          }
    556          
    557          
    558          /*******************************************************************************
    559           * @fn          halRestoreSleepLevel
    560           *
    561           * @brief       Restore the deepest timer sleep level.
    562           *
    563           * input parameters
    564           *
    565           * @param       None
    566           *
    567           * output parameters
    568           *
    569           * @param       None.
    570           *
    571           * @return      None.
    572           */
    573          void halRestoreSleepLevel( void )
    574          {
    575            // Stub
    576          #ifdef PM_TEST
    577            osal_start_timerEx (Hal_TaskID, HAL_SLEEP_TIMER_EVENT, 1000);
    578          #endif // PM_TEST
    579          }
    580          
    581          
    582          /*******************************************************************************
    583           * @fn          halSleepTimerIsr
    584           *
    585           * @brief       Sleep timer ISR.
    586           *
    587           * input parameters
    588           *
    589           * None.
    590           *
    591           * output parameters
    592           *
    593           * @param       None.
    594           *
    595           * @return      None.
    596           */
    597          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
    598          {
    599            HAL_ENTER_ISR();
    600          
    601            HAL_SLEEP_TIMER_CLEAR_INT();
    602          
    603          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    604            halSleepInt = TRUE;
    605          #endif // HAL_SLEEP_DEBUG_POWER_MODE
    606          
    607            CLEAR_SLEEP_MODE();
    608          
    609            HAL_EXIT_ISR();
    610          
    611            return;
    612          }
    613          
    614          /*******************************************************************************
    615           */
    616          

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0      0  TimerElapsed
       0      0      0  halRestoreSleepLevel
       0      0     24  halSetSleepMode
       0      0     28  halSleep
                          0 0 24 -> HalKeyEnterSleep
                          0 0 24 -> HalKeyExitSleep
                          0 0 24 -> HalLedEnterSleep
                          0 0 24 -> HalLedExitSleep
                          0 0 24 -> LL_PowerOffReq
                          0 0 24 -> LL_PowerOnReq
                          0 0 24 -> LL_TimeToNextRfEvent
                          0 0 24 -> halSetSleepMode
                          0 0 24 -> halSleepReadTimer
                          0 0 28 -> halSleepSetTimer
       3      0     28  halSleepReadTimer
       0      0     44  halSleepSetTimer
       4      0      0  halSleepTimerIsr


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  ?<Initializer for halSleepPconValue>
       6  ??TimerElapsed?relay
       6  ??halRestoreSleepLevel?relay
       6  ??halSetSleepMode?relay
       6  ??halSleep?relay
       6  ??halSleepReadTimer?relay
       6  ??halSleepSetTimer?relay
       3  ??halSleepTimerIsr??INTVEC 43
       9  ?Subroutine0
       1  IEN2
       1  PCON
       1  SLEEPCMD
       1  ST0
       1  ST1
       1  ST2
       1  STLOAD
      11  TimerElapsed
       1  _A_IEN0
       1  _A_IEN1
       1  _A_IRCON
       4  __Constant_43
       4  __Constant_7d
       4  __Constant_9c41
       4  __Constant_ff0000
       4  __Constant_ff0001
       4  __Constant_ffffffe7
       1  halPwrMgtMode
       3  halRestoreSleepLevel
       8  halSetSleepMode
     402  halSleep
       1  halSleepPconValue
      70  halSleepReadTimer
      97  halSleepSetTimer
      36  halSleepTimerIsr
       1  wakeForRF

 
 592 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   1 byte  in segment DATA_I
   1 byte  in segment DATA_ID
   3 bytes in segment INTVEC
  36 bytes in segment NEAR_CODE
  10 bytes in segment SFR_AN
   8 bytes in segment SLEEP_CODE
  24 bytes in segment XDATA_ROM_C
   2 bytes in segment XDATA_Z
 
 673 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of CONST memory (+ 24 bytes shared)
   1 byte  of DATA  memory (+ 10 bytes shared)
   2 bytes of XDATA memory

Errors: none
Warnings: none
