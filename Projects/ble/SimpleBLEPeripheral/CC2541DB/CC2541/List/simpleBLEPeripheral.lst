###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             25/Mar/2014  16:59:41 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\Source\simpleBLEPeripheral.c   #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheral\CC2541DB\..\..\config\build #
#                          Components.cfg (-DBROADCASTER_CFG=0x01             #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheral\CC2541DB\buildConfig #
#                          .cfg (-DHOST_CONFIG=PERIPHERAL_CFG                 #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\Source\simpleBLEPeripheral.c   #
#                          -D INT_HEAP_LEN=3074 -D HALNODEBUG -D              #
#                          OSAL_CBTIMER_NUM_TASKS=1 -D xHAL_AES_DMA=TRUE -D   #
#                          HAL_DMA=TRUE -D POWER_SAVING -D xPLUS_BROADCASTER  #
#                          -D HAL_LCD=TRUE -D HAL_LED=TRUE -D HAL_UART=TRUE   #
#                          -D HAL_ADC=TRUE -lcN E:\TexasInstruments\BLE-CC254 #
#                          x-1.4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\ #
#                          CC2541\List\ -o E:\TexasInstruments\BLE-CC254x-1.4 #
#                          .0\Projects\ble\SimpleBLEPeripheral\CC2541DB\CC254 #
#                          1\Obj\ -e --debug --core=plain --dptr=16,1         #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheral\CC2541DB\..\..\common\ -I   #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\include\ -I     #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\hal\include\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\..\ #
#                          ..\..\..\Components\hal\target\CC2541EB\ -I        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\osal\include\ -I E:\TexasInstruments\BLE-CC254x- #
#                          1.4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\.. #
#                          \..\..\..\Components\services\saddr\ -I            #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\ble\include\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheral\CC2541DB\..\ #
#                          ..\..\..\Components\ble\controller\phy\ -I         #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\ble\controller\include\ -I                       #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\..\..\Component #
#                          s\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1.4.0 #
#                          \Projects\ble\SimpleBLEPeripheral\CC2541DB\..\..\. #
#                          .\..\Components\ble\host\ -I                       #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\common\cc2540\  #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheral\CC2541DB\..\..\common\npi\n #
#                          pi_np\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheral\CC2541DB\..\..\Profi #
#                          les\Roles\ -I E:\TexasInstruments\BLE-CC254x-1.4.0 #
#                          \Projects\ble\SimpleBLEPeripheral\CC2541DB\..\..\P #
#                          rofiles\SimpleProfile\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\..\..\Profiles\DevInf #
#                          o\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Project #
#                          s\ble\SimpleBLEPeripheral\CC2541DB\..\..\Profiles\ #
#                          Batt\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Proj #
#                          ects\ble\SimpleBLEPeripheral\CC2541DB\..\..\Profil #
#                          es\HIDDev\ -Ohz                                    #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\CC2541\List\simpleBLE #
#                          Peripheral.lst                                     #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheral\CC2541DB\CC2541\Obj\simpleBLEP #
#                          eripheral.r51                                      #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\SimpleBLEPeripheral\Source\simpleBLEPeripheral.c
      1          /**************************************************************************************************
      2           Filename:       simpleBLEPeripheral.c
      3           Revised:        $Date: 2010-08-06 08:56:11 -0700 (Fri, 06 Aug 2010) $
      4           Revision:       $Revision: 23333 $
      5          
      6           Description:    This file contains the Simple BLE Peripheral sample application
      7           for use with the CC2540 Bluetooth Low Energy Protocol Stack.
      8          
      9           Copyright 2010 - 2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11           IMPORTANT: Your use of this Software is limited to those specific rights
     12           granted under the terms of a software license agreement between the user
     13           who downloaded the software, his/her employer (which must be your employer)
     14           and Texas Instruments Incorporated (the "License").  You may not use this
     15           Software unless you agree to abide by the terms of the License. The License
     16           limits your use, and you acknowledge, that the Software may not be modified,
     17           copied or distributed unless embedded on a Texas Instruments microcontroller
     18           or used solely and exclusively in conjunction with a Texas Instruments radio
     19           frequency transceiver, which is integrated into your product.  Other than for
     20           the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21           works of, modify, distribute, perform, display or sell this Software and/or
     22           its documentation for any purpose.
     23          
     24           YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25           PROVIDED �AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26           INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27           NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28           TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29           NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30           LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31           INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32           OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33           OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34           (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36           Should you have any questions regarding your right to use this Software,
     37           contact Texas Instruments Incorporated at www.TI.com.
     38           **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "bcomdef.h"
     45          #include "OSAL.h"
     46          #include "OSAL_PwrMgr.h"
     47          #include "osal_snv.h"
     48          
     49          #include "OnBoard.h"
     50          #include "hal_adc.h"
     51          #include "hal_led.h"
     52          #include "hal_key.h"
     53          #include "hal_lcd.h"
     54          #include "SimpleBLESerialUart.h"
     55          
     56          #include "gatt.h"
     57          
     58          #include "hci.h"
     59          
     60          #include "gapgattserver.h"
     61          #include "gattservapp.h"
     62          #include "devinfoservice.h"
     63          #include "simpleGATTprofile.h"
     64          
     65          #if defined ( PLUS_BROADCASTER )
     66          #include "peripheralBroadcaster.h"
     67          #else
     68          #include "peripheral.h"
     69          #endif
     70          
     71          #include "gapbondmgr.h"
     72          
     73          #include "simpleBLEPeripheral.h"
     74          
     75          #if defined FEATURE_OAD
     76          #include "oad.h"
     77          #include "oad_target.h"
     78          #endif
     79          
     80          #include "hal_i2c.h"
     81          #include "hal_eeprom.h"
     82          #include "hal_at24c32.h"
     83          #include "hal_ds1307.h"
     84          #include "SimpleEepromUtils.h"
     85          #include "SimpleRTCInterrupt.h"
     86          #include "SimpleBLESPIFlash.h"
     87          #include "battservice.h"
     88          #include "SimpleTemperature.h"
     89          #include "SimpleDS18B20.h"
     90          #include "Simplepasscode.h"
     91          /*********************************************************************
     92           * MACROS
     93           */
     94          
     95          /*********************************************************************
     96           * CONSTANTS
     97           */
     98          
     99          // How often to perform periodic event
    100          #define SBP_PERIODIC_EVT_PERIOD                   5000
    101          
    102          #define TEMP_CHECK_PERIOD                         5000
    103          
    104          // How often to check battery voltage (in ms)
    105          #define BATTERY_CHECK_PERIOD                     10000////////////////////////////////////batt
    106          
    107          // What is the advertising interval when device is discoverable (units of 625us, 160=100ms)
    108          #define DEFAULT_ADVERTISING_INTERVAL          160//16000
    109          /*//范围20MS-10.24S之间 除去广播延时时间0-10ms，为其可设置的范围。
    110          //若广播事件是可扫描无向事件或非连接无向事件 其值不得小于100MS，若广播事件是可连接无向事件，其值可以为20MS或者更大   
    111          //与手机通信过程中用的是,默认设置  GAP_ADTYPE_ADV_IND即可连接无向事件  测功耗时可以适当调整其值 */
    112          // Whether to enable automatic parameter update request when a connection is formed
    113          #define DEFAULT_ENABLE_UPDATE_REQUEST        TRUE 
    114          
    115          // Limited discoverable mode advertises for 30.72s, and then stops
    116          // General discoverable mode advertises indefinitely
    117          
    118          #if defined ( CC2540_MINIDK )
    119          #define DEFAULT_DISCOVERABLE_MODE             GAP_ADTYPE_FLAGS_LIMITED
    120          #else
    121          #define DEFAULT_DISCOVERABLE_MODE             GAP_ADTYPE_FLAGS_GENERAL
    122          #endif  // defined ( CC2540_MINIDK )
    123          // Minimum connection interval (units of 1.25ms, 80=100ms) if automatic parameter update request is enabled
    124          #define DEFAULT_DESIRED_MIN_CONN_INTERVAL     80
    125          
    126          // Maximum connection interval (units of 1.25ms, 800=1000ms) if automatic parameter update request is enabled
    127          #define DEFAULT_DESIRED_MAX_CONN_INTERVAL    180
    128          
    129          // Slave latency to use if automatic parameter update request is enabled
    130          #define DEFAULT_DESIRED_SLAVE_LATENCY         0//10  参数更新打开 与手机通信时 要小于4
    131          
    132          // Supervision timeout value (units of 10ms, 1000=10s) if automatic parameter update request is enabled
    133          #define DEFAULT_DESIRED_CONN_TIMEOUT        500//与手机通信时 要小于等于6S
    134          
    135          // Company Identifier: Texas Instruments Inc. (13)
    136          #define TI_COMPANY_ID                         0x000D
    137          
    138          #define INVALID_CONNHANDLE                    0xFFFF
    139          
    140          // Length of bd addr as a string
    141          #define B_ADDR_STR_LEN                        15
    142          
    143          #if defined ( PLUS_BROADCASTER )
    144          #define ADV_IN_CONN_WAIT                    500 // delay 500 ms
    145          #endif
    146          
    147          // GAP connection handle
    148          static uint16 gapConnHandle;
    149          
    150          extern uint8 SBP_UART_STUDY_CMD;
    151          extern uint8 SBP_UART_STUDY_CMD_LEN;
    152          
    153          /*************************************************************
    154           *  recv data define
    155           */
    156          //XDATA uint8 a[3000]={0};
    157          extern UartState u_state;
    158          #define TRANSFER_DATA_SIGN 0xFE
    159          #define TRANSFER_DATA_SIGN_RE 0xFF
    160          //#define UART_DATA_START_INDEX 2
    161          //#define one_time_data_len 125
    162          // uint8 code recv_value1[2540] = { 0 };
    163          static uint8  recv_value[128] = { 0 };
    164          static uint8 TRANSFER_DATA_STATE_IN = FALSE;
    165          //static char newValueBuf[20] = { 0 };
    166          static uint8 data_len = 0, cur_data_len = 0, data_len_index = 0;
    167          
    168          /*********************************************************************
    169           * SPI FLASH
    170           */
    171          uint8 buf[20];
    172          uint8 bufrx[20];
    173          
    174          /*********************************************************************
    175           * temperature
    176           */
    177          uint8 temperature[20];
    178          uint8 temp_18b20[10];
    179          uint8 temp_flag=0;
    180          uint8 temp_18b20_flag=0;
    181          /*************************************************************
    182           *  LIST
    183           */
    184          
    185           typedef struct
    186          {           
    187            
    188            uint8 listlen;                   
    189            uint8 value1[2]; 
    190            uint8 value2[2];                   
    191            uint8 value3[2]; 
    192            uint8 value4[2]; 
    193            uint8 value5[2]; 
    194            uint8 value6[2];  
    195          }list;
    196          
    197          list current_list={1,{0},{0},{0},{0},{0},{0}};
    198          
    199          /*********************************************************************
    200           * EVENT
    201           */
    202          uint16 peripheral_event=0;
    203          uint8 time_databuf_read[20]={0};
    204          uint8 time_datalen_read=0;
    205          
    206          /*********************************************************************
    207           * GLOBAL VARIABLES
    208           */
    209          
    210          /*********************************************************************
    211           * EXTERNAL VARIABLES
    212           */
    213          
    214          /*********************************************************************
    215           * EXTERNAL FUNCTIONS
    216           */
    217          
    218          /*********************************************************************
    219           * LOCAL VARIABLES
    220           */
    221          static uint8 simpleBLEPeripheral_TaskID; // Task ID for internal task/event processing
    222          
    223          static gaprole_States_t gapProfileState = GAPROLE_INIT;
    224          
    225          // GAP - SCAN RSP data (max size = 31 bytes)
    226          static uint8 scanRspData[] = {
    227          // complete name
    228          		0x14,// length of this data
    229          		GAP_ADTYPE_LOCAL_NAME_COMPLETE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    230          		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    231          
    232          		// connection interval range
    233          		0x05,// length of this data
    234          		GAP_ADTYPE_SLAVE_CONN_INTERVAL_RANGE, LO_UINT16(DEFAULT_DESIRED_MIN_CONN_INTERVAL), // 100ms
    235          		HI_UINT16(DEFAULT_DESIRED_MIN_CONN_INTERVAL), LO_UINT16(DEFAULT_DESIRED_MAX_CONN_INTERVAL), // 1s
    236          		HI_UINT16(DEFAULT_DESIRED_MAX_CONN_INTERVAL),
    237          
    238          		// Tx power level
    239          		0x02,// length of this data
    240          		GAP_ADTYPE_POWER_LEVEL, 0 // 0dBm
    241          		};
    242          
    243          // GAP - Advertisement data (max size = 31 bytes, though this is
    244          // best kept short to conserve power while advertisting)
    245          static uint8 advertData[] = {
    246          // Flags; this sets the device to use limited discoverable
    247          // mode (advertises for 30 seconds at a time) instead of general
    248          // discoverable mode (advertises indefinitely)
    249          		0x02,// length of this data
    250          		GAP_ADTYPE_FLAGS, DEFAULT_DISCOVERABLE_MODE | GAP_ADTYPE_FLAGS_BREDR_NOT_SUPPORTED,
    251          
    252          		// service UUID, to notify central devices what services are included
    253          		// in this peripheral
    254          		0x03,// length of this data
    255          		GAP_ADTYPE_16BIT_MORE, // some of the UUID's, but not all
    256          		LO_UINT16(SIMPLEPROFILE_SERV_UUID), HI_UINT16(SIMPLEPROFILE_SERV_UUID),
    257          
    258          };
    259          
    260          /*********************************************************************
    261           * LOCAL FUNCTIONS
    262           */
    263          static void simpleBLEPeripheral_ProcessOSALMsg(osal_event_hdr_t *pMsg);
    264          static void peripheralStateNotificationCB(gaprole_States_t newState);
    265          static void performPeriodicTask(void);
    266          static void simpleProfileChangeCB(uint8 paramID);
    267          static void simpleBLEPeripheral_HandleKeys(uint8 shift, uint8 keys);
    268          //static void simpleBLEPeripheralPasscodeCB(uint8 *deviceAddr, uint16 connectionHandle, uint8 uiInputs, uint8 uiOutputs);
    269          static void simpleBLEPeripheralPairStateCB(uint16 connHandle, uint8 state, uint8 status);
    270          static char *bdAddr2Str(uint8 *pAddr);
    271          static char *hex2Str(uint8 *hexcode);
    272          //static void gettemp(void);
    273          //static void updateDeviceName(char *name, uint8 len);
    274          //static uint32 atoi(uint8 s[]);
    275          //static void Uartsend_irdata(void);
    276          //static void Receive_Save_Uartsend_irdata(void);
    277          
    278          /*********************************************************************
    279           * PROFILE CALLBACKS
    280           */
    281          
    282          // GAP Role Callbacks
    283          static gapRolesCBs_t simpleBLEPeripheral_PeripheralCBs = { peripheralStateNotificationCB, // Profile State Change Callbacks
    284          		NULL // When a valid RSSI is read from controller (not used by application)
    285          		};
    286          
    287          // GAP Bond Manager Callbacks
    288          static gapBondCBs_t simpleBLEPeripheral_BondMgrCBs = { NULL, // Passcode callback (not used by application)
    289          		simpleBLEPeripheralPairStateCB // Pairing / Bonding state Callback (not used by application)
    290          		};
    291          
    292          // Simple GATT Profile Callbacks
    293          static simpleProfileCBs_t simpleBLEPeripheral_SimpleProfileCBs = { simpleProfileChangeCB // Charactersitic value change callback
    294          		};
    295          
    296          /*********************************************************************
    297           * @fn      pairStateCB
    298           * @brief   Pairing state callback.
    299           * @return  none
    300           */
    301          static void simpleBLEPeripheralPairStateCB(uint16 connHandle, uint8 state, uint8 status) {
    302          	if (state == GAPBOND_PAIRING_STATE_STARTED) {
    303          		HalLcdWriteString("Pairing started", HAL_LCD_LINE_7);
    304          	} else if (state == GAPBOND_PAIRING_STATE_COMPLETE) {
    305          		if (status == SUCCESS) {
    306          			HalLcdWriteString("Pairing success", HAL_LCD_LINE_7);
    307          		} else {
    308          			HalLcdWriteStringValue("Pairing fail", status, 10, HAL_LCD_LINE_7);
    309          			uint8 a = GAPRole_TerminateConnection();
    310          			HalLcdWriteStringValue("Pairing fail--a", a, 10, HAL_LCD_LINE_7);
    311          		}
    312          	} else if (state == GAPBOND_PAIRING_STATE_BONDED) {
    313          		if (status == SUCCESS) {
    314          			HalLcdWriteString("Bonding success", HAL_LCD_LINE_1);
    315          		}
    316          	}
    317          
    318          	//osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_ZEKEZANG_EVT, 5000);
    319          }
    320          
    321          /*********************************************************************
    322           * @fn      simpleBLECentralPasscodeCB
    323           * @brief   Passcode callback.
    324           * @return  none
    325          
    326           static void simpleBLEPeripheralPasscodeCB(uint8 *deviceAddr, uint16 connectionHandle, uint8 uiInputs, uint8 uiOutputs) {
    327           HalLcdWriteStringValue("uiInputs:", uiInputs, 10, HAL_LCD_LINE_5);
    328           HalLcdWriteStringValue("uiOutputs", uiOutputs, 10, HAL_LCD_LINE_6);
    329           }
    330           */
    331          
    332          /*********************************************************************
    333           * @fn      readWriteFlash
    334           * @brief   readWriteFlash
    335           * @return  none
    336          
    337           static uint32 passs = 0;
    338           static void readWriteFlash() {
    339           uint8 * aa;
    340           aa = osal_msg_allocate(15);
    341           osal_memset(aa, 0, 15);
    342           osal_memcpy(aa, "as", 2);
    343           uint16 p = 1234;
    344           if (osal_snv_write(0xE0, sizeof(uint16), &p) == SUCCESS) {
    345           HalLcdWriteString("write ok", HAL_LCD_LINE_2);
    346           }
    347           osal_msg_deallocate(aa);
    348           uint8 bb[15] = { 0x0 };
    349           uint16 bb = 0;
    350           if (osal_snv_read(0xE0, 15, &bb) == SUCCESS) {
    351           HalLcdWriteString("read ok", HAL_LCD_LINE_2);
    352           passs = bb;
    353           }
    354           }
    355           */
    356          
    357          
    358          /*********************************************************************
    359           * PUBLIC FUNCTIONS
    360           */
    361          
    362          /*********************************************************************
    363           * @fn      SimpleBLEPeripheral_Init
    364           *
    365           * @brief   Initialization function for the Simple BLE Peripheral App Task.
    366           *          This is called during initialization and should contain
    367           *          any application specific initialization (ie. hardware
    368           *          initialization/setup, table initialization, power up
    369           *          notificaiton ... ).
    370           *
    371           * @param   task_id - the ID assigned by OSAL.  This ID should be
    372           *                    used to send messages and set timers.
    373           *
    374           * @return  none
    375           */
    376          void SimpleBLEPeripheral_Init(uint8 task_id) {
    377          
    378            simpleBLEPeripheral_TaskID = task_id;
    379          	SbpHalUART_Init(task_id);
    380                  
    381          	// Setup the GAP Peripheral Role Profile
    382          	{
    383          
    384          #if defined( CC2540_MINIDK )
    385          		// For the CC2540DK-MINI keyfob, device doesn't start advertising until button is pressed
    386          		uint8 initial_advertising_enable = FALSE;
    387          #else
    388          		// For other hardware platforms, device starts advertising upon initialization
    389          		uint8 initial_advertising_enable = TRUE;
    390          #endif
    391          
    392          		// By setting this to zero, the device will go into the waiting state after
    393          		// being discoverable for 30.72 second, and will not being advertising again
    394          		// until the enabler is set back to TRUE
    395          		uint16 gapRole_AdvertOffTime = 0;
    396          
    397          		uint8 enable_update_request = DEFAULT_ENABLE_UPDATE_REQUEST;
    398          		uint16 desired_min_interval = DEFAULT_DESIRED_MIN_CONN_INTERVAL;
    399          		uint16 desired_max_interval = DEFAULT_DESIRED_MAX_CONN_INTERVAL;
    400          		uint16 desired_slave_latency = DEFAULT_DESIRED_SLAVE_LATENCY;
    401          		uint16 desired_conn_timeout = DEFAULT_DESIRED_CONN_TIMEOUT;
    402          
    403          		// Set the GAP Role Parameters
    404          		GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8), &initial_advertising_enable);
    405          		GAPRole_SetParameter(GAPROLE_ADVERT_OFF_TIME, sizeof(uint16), &gapRole_AdvertOffTime);
    406          
    407          		GAPRole_SetParameter(GAPROLE_SCAN_RSP_DATA, sizeof(scanRspData), scanRspData);
    408          		GAPRole_SetParameter(GAPROLE_ADVERT_DATA, sizeof(advertData), advertData);
    409          
    410          		GAPRole_SetParameter(GAPROLE_PARAM_UPDATE_ENABLE, sizeof(uint8), &enable_update_request);
    411          		GAPRole_SetParameter(GAPROLE_MIN_CONN_INTERVAL, sizeof(uint16), &desired_min_interval);
    412          		GAPRole_SetParameter(GAPROLE_MAX_CONN_INTERVAL, sizeof(uint16), &desired_max_interval);
    413          		GAPRole_SetParameter(GAPROLE_SLAVE_LATENCY, sizeof(uint16), &desired_slave_latency);
    414          		GAPRole_SetParameter(GAPROLE_TIMEOUT_MULTIPLIER, sizeof(uint16), &desired_conn_timeout);
    415          	}
    416          
    417          	//readWriteFlash();
    418          
    419          
    420          	// Set advertising interval
    421          	{
    422          		uint16 advInt = DEFAULT_ADVERTISING_INTERVAL;
    423          
    424          		GAP_SetParamValue(TGAP_LIM_DISC_ADV_INT_MIN, advInt);
    425          		GAP_SetParamValue(TGAP_LIM_DISC_ADV_INT_MAX, advInt);
    426          		GAP_SetParamValue(TGAP_GEN_DISC_ADV_INT_MIN, advInt);
    427          		GAP_SetParamValue(TGAP_GEN_DISC_ADV_INT_MAX, advInt);
    428          	}
    429                  set_passkey();
    430          
    431          
    432          	// Initialize GATT attributes
    433          	GGS_AddService(GATT_ALL_SERVICES); // GAP
    434          	GATTServApp_AddService(GATT_ALL_SERVICES); // GATT attributes
    435          	DevInfo_AddService(); // Device Information Service
    436          	SimpleProfile_AddService(GATT_ALL_SERVICES); // Simple GATT Profile
    437                  Batt_AddService();     // Battery Service
    438                  
    439                  
    440                  
    441                  
    442          #if defined FEATURE_OAD
    443          			VOID OADTarget_AddService(); // OAD Profile
    444          #endif
    445          
    446          	// Setup the SimpleProfile Characteristic Values
    447          	{
    448          	
    449          		uint8 charValue4 = 4;
    450                          uint8 charValue1[SIMPLEPROFILE_CHAR1_LEN] = { 0 };
    451                          uint8 charValue2[SIMPLEPROFILE_CHAR2_LEN] = { 0 };
    452                          uint8 charValue3[SIMPLEPROFILE_CHAR3_LEN] = { 0 };
    453                          uint8 charValue5[SIMPLEPROFILE_CHAR5_LEN] = { 0 };
    454                          uint8 charValue6[SIMPLEPROFILE_CHAR6_LEN] = { 0 };
    455                          uint8 charValue7[SIMPLEPROFILE_CHAR7_LEN] = { 0 };
    456          		
    457          		
    458          		SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR4, sizeof(uint8), &charValue4);
    459          		
    460                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR1, SIMPLEPROFILE_CHAR1_LEN, charValue1);
    461                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR2, SIMPLEPROFILE_CHAR2_LEN, charValue2);
    462                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR3, SIMPLEPROFILE_CHAR3_LEN, charValue3);
    463                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR5, SIMPLEPROFILE_CHAR5_LEN, charValue5);
    464                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR6, SIMPLEPROFILE_CHAR6_LEN, charValue6);
    465                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, charValue7);
    466                       
    467          	}
    468          
    469          	HalLcdWriteString("BLE slave aico", HAL_LCD_LINE_1);////////////////////////////////////////////////////////////////////////////
    470          
    471          	// Register callback with SimpleGATTprofile
    472          	VOID SimpleProfile_RegisterAppCBs(&simpleBLEPeripheral_SimpleProfileCBs);
    473          
    474          	//who open who byebye
    475          	//HCI_EXT_ClkDivOnHaltCmd(HCI_EXT_ENABLE_CLK_DIVIDE_ON_HALT); no no no...
    476          
    477          	// Register for all key events - This app will handle all key events
    478          	RegisterForKeys(simpleBLEPeripheral_TaskID);
    479          
    480          #if defined ( DC_DC_P0_7 )
    481          	// Enable stack to toggle bypass control on TPS62730 (DC/DC converter)
    482          	HCI_EXT_MapPmIoPortCmd( HCI_EXT_PM_IO_PORT_P0, HCI_EXT_PM_IO_PORT_PIN7 );
    483          #endif // defined ( DC_DC_P0_7 )
    484          	// Setup a delayed profile startup
    485          	osal_set_event(simpleBLEPeripheral_TaskID, SBP_START_DEVICE_EVT);
    486                  
    487                  
    488                   // initialize the ADC for battery reads
    489                  HalAdcInit();
    490          
    491          	/***********************************test something zekezang**********************************/
    492          	//HalLcdWriteString(" start", HAL_LCD_LINE_1);
    493          	
    494                      XNV_SPI_INIT();
    495                  //设置P1.0端口方向为输出
    496                  P0DIR |= BV(4);
    497                  
    498                  //设置P1.0端口为GPIO功能
    499                  P0SEL &= ~BV(4);
    500                  
    501               
    502          
    503          
    504          	/***********************************test something zekezang**********************************/
    505          }
    506          
    507          /*********************************************************************
    508           * @fn      SimpleBLEPeripheral_ProcessEvent
    509           *
    510           * @brief   Simple BLE Peripheral Application Task event processor.  This function
    511           *          is called to process all events for the task.  Events
    512           *          include timers, messages and any other user defined events.
    513           *
    514           * @param   task_id  - The OSAL assigned task ID.
    515           * @param   events - events to process.  This is a bit map and can
    516           *                   contain more than one event.
    517           *
    518           * @return  events not processed
    519           */
    520          uint16 SimpleBLEPeripheral_ProcessEvent(uint8 task_id, uint16 events) {
    521          
    522          	VOID task_id; // OSAL required parameter that isn't used in this function
    523                  uint8 i;
    524          	if (events & SYS_EVENT_MSG) {
    525          		uint8 *pMsg;
    526          
    527          		if ((pMsg = osal_msg_receive(simpleBLEPeripheral_TaskID)) != NULL) {
    528          			simpleBLEPeripheral_ProcessOSALMsg((osal_event_hdr_t *) pMsg);
    529          
    530          			// Release the OSAL message
    531          			VOID osal_msg_deallocate(pMsg);
    532          		}
    533          
    534          		// return unprocessed events
    535          		return (events ^ SYS_EVENT_MSG);
    536          	}
    537          
    538          	if (events & SBP_START_DEVICE_EVT) {
    539          		// Start the Device
    540          		GAPRole_StartDevice(&simpleBLEPeripheral_PeripheralCBs);
    541          
    542          		// Start Bond Manager
    543          		GAPBondMgr_Register(&simpleBLEPeripheral_BondMgrCBs);
    544          
    545          		// Set timer for first periodic event
    546          		//osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_PERIODIC_EVT, SBP_PERIODIC_EVT_PERIOD);
    547                          
    548                          // Set timer for first battery read event
    549                          //osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_PERIODIC_EVT, BATTERY_CHECK_PERIOD );
    550                          
    551          
    552                          //osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_TEMP_EVT, TEMP_CHECK_PERIOD );
    553                    
    554          		return (events ^ SBP_START_DEVICE_EVT);
    555          	}
    556          
    557          //	if (events & SBP_PERIODIC_EVT) {
    558          
    559                         // Restart timer
    560          //		if (SBP_PERIODIC_EVT_PERIOD) {
    561          //			osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_PERIODIC_EVT, SBP_PERIODIC_EVT_PERIOD);
    562          //		}
    563          //
    564          //		// Perform periodic application task
    565          //		performPeriodicTask();
    566          //               
    567          //		return (events ^ SBP_PERIODIC_EVT);
    568          //	}
    569          
    570          //	if (events & SBP_ZEKEZANG_EVT) {
    571          //		uint8 initial_advertising_enable = FALSE;
    572          //		GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8), &initial_advertising_enable);
    573          //		return (events ^ SBP_ZEKEZANG_EVT);
    574          //	}
    575          
    576          //	if (events & SBP_SEND_IRDATA_EVT) {
    577          //		HalLcdWriteString("send plan compl", HAL_LCD_LINE_4);
    578          //		return (events ^ SBP_SEND_IRDATA_EVT);
    579          //	}
    580          //
    581          //	if (events & SBP_ADV_IN_CONNECTION_EVT) {
    582          //		uint8 turnOnAdv = TRUE;
    583          //		// Turn on advertising while in a connection
    584          //		GAPRole_SetParameter(GAPROLE_ADVERT_ENABLED, sizeof(uint8), &turnOnAdv);
    585          //
    586          //		return (events ^ SBP_ADV_IN_CONNECTION_EVT);
    587          //	}
    588                  
    589          //        if (events & SBP_TEMP_EVT) {
    590          //             
    591          //	       return (events ^ SBP_TEMP_EVT);
    592          //	}
    593                  
    594                  if (events & SBP_SEND_IRDATA_EVT1) {
    595          		
    596                          HalSPIRead(current_list.value1[0]*256,&time_datalen_read,1);
    597          		    //延时
    598                          for(i=20; i>0; i--)
    599                            delay_nus(50);
    600                          HalSPIRead(current_list.value1[0]*256+1,time_databuf_read,time_datalen_read-4);
    601                          
    602          		HalLcdWriteString(hex2Str(time_databuf_read), HAL_LCD_LINE_4);
    603          
    604                          current_list.listlen--;
    605                          SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
    606                          HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
    607                          HalLcdWriteString("event1 ok", HAL_LCD_LINE_5);
    608          
    609                          peripheral_event^=SBP_SEND_IRDATA_EVT1;  
    610          		return (events ^ SBP_SEND_IRDATA_EVT1);
    611          	}
    612          	if (events & SBP_SEND_IRDATA_EVT2) {
    613          		
    614                         HalSPIRead(current_list.value2[0]*256,&time_datalen_read,1);
    615          		    //延时
    616                         for(i=20; i>0; i--)
    617                            delay_nus(50);
    618                          HalSPIRead(current_list.value2[0]*256+1,time_databuf_read,time_datalen_read-4);
    619                          
    620          		HalLcdWriteString(hex2Str(time_databuf_read), HAL_LCD_LINE_4);
    621          
    622                          current_list.listlen--;
    623                          SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
    624                          HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
    625                          HalLcdWriteString("event2 ok", HAL_LCD_LINE_5);
    626          
    627                          peripheral_event^=SBP_SEND_IRDATA_EVT2;
    628                          //peripheral_event=events ^ SBP_SEND_IRDATA_EVT2;
    629          		return (events ^ SBP_SEND_IRDATA_EVT2);
    630          	}
    631          	if (events & SBP_SEND_IRDATA_EVT3) {
    632          		
    633                         HalSPIRead(current_list.value3[0]*256,&time_datalen_read,1);
    634          		    //延时
    635                         for(i=20; i>0; i--)
    636                            delay_nus(50);
    637                          HalSPIRead(current_list.value3[0]*256+1,time_databuf_read,time_datalen_read-4);
    638                          
    639          		HalLcdWriteString(hex2Str(time_databuf_read), HAL_LCD_LINE_4);
    640          
    641                          current_list.listlen--;
    642                          SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
    643                          HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
    644                          HalLcdWriteString("event3 ok", HAL_LCD_LINE_5);
    645          
    646                          peripheral_event^=SBP_SEND_IRDATA_EVT3;
    647                          //peripheral_event=events ^ SBP_SEND_IRDATA_EVT3;
    648          		return (events ^ SBP_SEND_IRDATA_EVT3);
    649          	}
    650                  if (events & SBP_SEND_IRDATA_EVT4) {
    651          		
    652                         HalSPIRead(current_list.value4[0]*256,&time_datalen_read,1);
    653          		    //延时
    654                          for(i=20; i>0; i--)
    655                            delay_nus(50);
    656                          HalSPIRead(current_list.value4[0]*256+1,time_databuf_read,time_datalen_read-4);
    657                          
    658          		HalLcdWriteString(hex2Str(time_databuf_read), HAL_LCD_LINE_4);
    659          
    660                          current_list.listlen--;
    661                          SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
    662                          HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
    663                          HalLcdWriteString("event4 ok", HAL_LCD_LINE_5);
    664          
    665                          peripheral_event^=SBP_SEND_IRDATA_EVT3;
    666                          //peripheral_event=events ^ SBP_SEND_IRDATA_EVT4;
    667          		return (events ^ SBP_SEND_IRDATA_EVT4);
    668          	}
    669                  if (events & SBP_SEND_IRDATA_EVT5) {
    670          		
    671                          HalSPIRead(current_list.value5[0]*256,&time_datalen_read,1);
    672          		    //延时
    673                          for(i=20; i>0; i--)
    674                            delay_nus(50);
    675                          HalSPIRead(current_list.value5[0]*256+1,time_databuf_read,time_datalen_read-4);
    676                          
    677          		HalLcdWriteString(hex2Str(time_databuf_read), HAL_LCD_LINE_4);
    678          
    679                          current_list.listlen--;
    680                          SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
    681                          HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
    682                          HalLcdWriteString("event5 ok", HAL_LCD_LINE_5);
    683                          peripheral_event^=SBP_SEND_IRDATA_EVT3;
    684                          //peripheral_event=events ^ SBP_SEND_IRDATA_EVT5;
    685          		return (events ^ SBP_SEND_IRDATA_EVT5);
    686          	}
    687          //        if (events & SBP_SEND_IRDATA_EVT6) {
    688          //		
    689          //                HalSPIRead(current_list.value6[0]*256,&time_datalen_read,1);
    690          //		    //延时
    691          //                for(i=20; i>0; i--)
    692          //                  delay_nus(50);
    693          //                HalSPIRead(current_list.value6[0]*256+1,time_databuf_read,time_datalen_read-4);
    694          //                
    695          //		HalLcdWriteString(hex2Str(time_databuf_read), HAL_LCD_LINE_4);
    696          //
    697          //                current_list.listlen--;
    698          //                SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
    699          //                HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
    700          //                 HalLcdWriteString("event6 ok", HAL_LCD_LINE_5);
    701          //               // peripheral_event^=SBP_SEND_IRDATA_EVT5;
    702          //                peripheral_event=events ^ SBP_SEND_IRDATA_EVT6;
    703          //		return (events ^ SBP_SEND_IRDATA_EVT6);
    704          //	}
    705          //        
    706                  
    707                  
    708          
    709          	return 0;
    710          }
    711          
    712          /*********************************************************************
    713           * @fn      simpleBLEPeripheral_ProcessOSALMsg
    714           *
    715           * @brief   Process an incoming task message.
    716           *
    717           * @param   pMsg - message to process
    718           *
    719           * @return  none
    720           */
    721          static void simpleBLEPeripheral_ProcessOSALMsg(osal_event_hdr_t *pMsg) {
    722          	switch (pMsg->event) {
    723          	case KEY_CHANGE:
    724          		simpleBLEPeripheral_HandleKeys(((keyChange_t *) pMsg)->state, ((keyChange_t *) pMsg)->keys);
    725          		break;
    726          	default:
    727          		// do nothing
    728          		break;
    729          	}
    730          }
    731          
    732          static void simpleBLEPeripheral_HandleKeys(uint8 shift, uint8 keys) {
    733              uint8 i;
    734          	if (keys & HAL_KEY_UP) {
    735          		//u_state = IR_DATA_STUDY_CMD_START_BEGIN_STATE;
    736          		//SbpHalUARTWrite(&SBP_UART_STUDY_CMD, SBP_UART_STUDY_CMD_LEN);
    737          	}
    738          
    739          	if (keys & HAL_KEY_LEFT) {
    740          //		HalLcdWriteString("change to de_paddkey_name", HAL_LCD_LINE_3);
    741          //                set_de_passkey();
    742          	}
    743                   if(keys ==(HAL_KEY_CENTER|HAL_KEY_LONG))
    744                    {
    745                       HalLcdWriteString("long ok", HAL_LCD_LINE_7);
    746                                HalLedSet(HAL_LED_3, HAL_LED_MODE_ON );   //开LED1
    747                                for(i=20; i>0; i--)
    748                                  delay_nus(50000);
    749                                HalLedSet(HAL_LED_3, HAL_LED_MODE_OFF );   //关LED1
    750                                for(i=20; i>0; i--)
    751                                  delay_nus(50000);
    752                    }
    753                     if(keys ==(HAL_KEY_CENTER|HAL_KEY_SHORT))
    754                    {
    755                       HalLcdWriteString(" ok", HAL_LCD_LINE_6);
    756                                HalLedSet(HAL_LED_1, HAL_LED_MODE_ON );   //开LED1
    757                                for(i=20; i>0; i--)
    758                                  delay_nus(50000);
    759                                HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF );   //关LED1
    760                                for(i=20; i>0; i--)
    761                                  delay_nus(50000);
    762                    }
    763          //        if (keys == HAL_KEY_CENTER) 
    764          //        {
    765          //             HalLcdWriteString(" ok", HAL_LCD_LINE_8);
    766          //                      HalLedSet(HAL_LED_3, HAL_LED_MODE_ON );   //开LED1
    767          //                      for(i=20; i>0; i--)
    768          //                        delay_nus(5000);
    769          //                      HalLedSet(HAL_LED_3, HAL_LED_MODE_OFF );   //关LED1
    770          //                      for(i=20; i>0; i--)
    771          //                        delay_nus(5000);
    772          //        }
    773                  
    774                  
    775          
    776          
    777          //	 if (keys & HAL_KEY_CENTER) {
    778          //           
    779          //          
    780          //                 if(keys & HAL_KEY_SHORT)
    781          //                 {
    782          //                   HalLcdWriteString("ok", HAL_LCD_LINE_6);
    783          //                   HalLedSet(HAL_LED_1, HAL_LED_MODE_ON );   //开LED1
    784          //                    for(i=20; i>0; i--)
    785          //                      delay_nus(5000);
    786          //                    HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF );   //关LED1
    787          //                    for(i=20; i>0; i--)
    788          //                      delay_nus(5000);
    789          //                    
    790          //                   
    791          //                 }
    792          //                 else if(keys & HAL_KEY_LONG)
    793          //                 {
    794          //                   HalLcdWriteString("long ok", HAL_LCD_LINE_7);
    795          //                    HalLedSet(HAL_LED_3, HAL_LED_MODE_ON );   //开LED1
    796          //                    for(i=20; i>0; i--)
    797          //                      delay_nus(5000);
    798          //                    HalLedSet(HAL_LED_3, HAL_LED_MODE_OFF );   //关LED1
    799          //                    for(i=20; i>0; i--)
    800          //                      delay_nus(5000);
    801          //                 }
    802          //                   
    803          //              
    804                          
    805                          
    806                          
    807                          
    808                          
    809          		//HalLcdWriteString("send after 3s...", HAL_LCD_LINE_4);
    810          		//osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT, 3000);
    811          	//}
    812                  
    813          	if (keys & HAL_KEY_RIGHT) {
    814          		//HalLcdWriteStringValue("data_len:", data_len, 10, HAL_LCD_LINE_2);
    815          	}
    816          
    817          }
    818          
    819          /*********************************************************************
    820           * @fn      peripheralStateNotificationCB
    821           *
    822           * @brief   Notification from the profile of a state change.
    823           *
    824           * @param   newState - new state
    825           *
    826           * @return  none
    827           */
    828          static void peripheralStateNotificationCB(gaprole_States_t newState) {
    829          
    830          	//HalLcdWriteStringValue("newState", newState, 10, HAL_LCD_LINE_4);
    831          
    832          	switch (newState) {
    833          	case GAPROLE_STARTED: {
    834          		uint8 ownAddress[B_ADDR_LEN];
    835          		uint8 systemId[DEVINFO_SYSTEM_ID_LEN];
    836          
    837          		GAPRole_GetParameter(GAPROLE_BD_ADDR, ownAddress);
    838          
    839          		// use 6 bytes of device address for 8 bytes of system ID value
    840          		systemId[0] = ownAddress[0];
    841          		systemId[1] = ownAddress[1];
    842          		systemId[2] = ownAddress[2];
    843          
    844          		// set middle bytes to zero
    845          		systemId[4] = 0x00;
    846          		systemId[3] = 0x00;
    847          
    848          		// shift three bytes up
    849          		systemId[7] = ownAddress[5];
    850          		systemId[6] = ownAddress[4];
    851          		systemId[5] = ownAddress[3];
    852          
    853          		DevInfo_SetParameter(DEVINFO_SYSTEM_ID, DEVINFO_SYSTEM_ID_LEN, systemId);
    854          
    855          		// Display device address
    856          		bdAddr2Str(ownAddress);
    857          		HalLcdWriteString(bdAddr2Str(ownAddress), HAL_LCD_LINE_3);
    858          		HalLcdWriteString("Initialized", HAL_LCD_LINE_3);
    859          	}
    860          		break;
    861          
    862          	case GAPROLE_ADVERTISING: {
    863          		HalLcdWriteString("Advertising", HAL_LCD_LINE_3);
    864          	}
    865          		break;
    866          
    867          	case GAPROLE_CONNECTED: {
    868          		HalLcdWriteString("Connected", HAL_LCD_LINE_3);
    869          		//simpleProfile_StateNotify( uint16 connHandle, attHandleValueNoti_t *pNoti )
    870          		GAPRole_GetParameter(GAPROLE_CONNHANDLE, &gapConnHandle);
    871          	}
    872          		break;
    873          
    874          	case GAPROLE_WAITING: {
    875          		HalLcdWriteString("Disconnected", HAL_LCD_LINE_3);
    876          	}
    877          		break;
    878          
    879          	case GAPROLE_WAITING_AFTER_TIMEOUT: {
    880          		HalLcdWriteString("Timed Out", HAL_LCD_LINE_3);
    881          	}
    882          		break;
    883          
    884          	case GAPROLE_ERROR: {
    885          		HalLcdWriteString("Error", HAL_LCD_LINE_3);
    886          	}
    887          		break;
    888          
    889          	default: {
    890          		HalLcdWriteString("", HAL_LCD_LINE_3);
    891          	}
    892          		break;
    893          
    894          	}
    895          
    896          	gapProfileState = newState;
    897          
    898          #if !defined( CC2540_MINIDK )
    899          	VOID gapProfileState; // added to prevent compiler warning with
    900          						  // "CC2540 Slave" configurations
    901          #endif
    902          
    903          }
    904          
    905          /*********************************************************************
    906           * @fn      performPeriodicTask
    907           *
    908           * @brief   Perform a periodic application task. This function gets
    909           *          called every five seconds as a result of the SBP_PERIODIC_EVT
    910           *          OSAL event. In this example, the value of the third
    911           *          characteristic in the SimpleGATTProfile service is retrieved
    912           *          from the profile, and then copied into the value of the
    913           *          the fourth characteristic.
    914           *
    915           * @param   none
    916           *
    917           * @return  none
    918           */
    919          static void performPeriodicTask(void) {
    920          	uint8 valueToCopy;
    921          	uint8 stat;
    922          
    923          	// Call to retrieve the value of the third characteristic in the profile
    924          	stat = SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR2, &valueToCopy);
    925          
    926          	if (stat == SUCCESS) {
    927          		/*
    928          		 * Call to set that value of the fourth characteristic in the profile. Note
    929          		 * that if notifications of the fourth characteristic have been enabled by
    930          		 * a GATT client device, then a notification will be sent every time this
    931          		 * function is called.
    932          		 */
    933                         // HalLcdWriteString("ok", HAL_LCD_LINE_5);
    934          		SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR4, sizeof(uint8), &valueToCopy);
    935          	}
    936          }
    937          
    938          /*********************************************************************
    939           * @fn      simpleProfileChangeCB
    940           * @brief   Callback from SimpleBLEProfile indicating a value change
    941           * @param   paramID - parameter ID of the value that was changed.
    942           *
    943           * @return  none
    944           */
    945          static void simpleProfileChangeCB(uint8 paramID) {
    946          	 //osal_memset(buf, 0, 20);
    947            uint8 valuechar1[20]={0},valuechar2[20]={0},valuechar3[20]={0},valuechar5[20]={0},valuechar6[20]={0},valuechar7[20]={0},valuechar8[20]={0};
    948          	 uint8 databuf_read[20]={0};
    949          	 uint8 datalen_read=0,i;
    950                   uint8  irdata_return[20]={0};
    951          	switch (paramID) {
    952          	case SIMPLEPROFILE_CHAR1://用于密码用户名修改
    953                       SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR1,valuechar1);
    954                       set_code_name(valuechar1);
    955          		break;
    956                          
    957                  case SIMPLEPROFILE_CHAR2://用于接收 遥控器 红外代码库
    958                       SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR2, valuechar2);
    959                     //  HalLcdWriteString(valuechar2, HAL_LCD_LINE_5);
    960          	
    961                      if ((valuechar2[0] == TRANSFER_DATA_SIGN) && (valuechar2[1] == TRANSFER_DATA_SIGN_RE)) 
    962          	     {
    963          			TRANSFER_DATA_STATE_IN = FALSE;
    964                                 
    965          	      }
    966                      
    967                      
    968          	   if ((valuechar2[3] != 0) && (!TRANSFER_DATA_STATE_IN)) 
    969          	    {
    970          			
    971                                  data_len = valuechar2[3];
    972          			TRANSFER_DATA_STATE_IN = TRUE;
    973          			data_len_index = 0;
    974          			osal_memset(recv_value, 0, data_len);
    975                         
    976          	    }
    977          	
    978          	  cur_data_len = osal_strlen((char*)valuechar2);//有问题 是0的话 长度不对
    979                   //  cur_data_len = sizeof(valuechar2);
    980                     HalLcdWriteStringValue("cur_data_len:",cur_data_len, 10, HAL_LCD_LINE_1); 
    981                     
    982          	   if (TRANSFER_DATA_STATE_IN) 
    983          	    {
    984          		osal_memcpy((recv_value + data_len_index), valuechar2, cur_data_len);
    985                          
    986          		data_len_index += cur_data_len;
    987                          
    988          	     }
    989                     //HalLcdWriteStringValue("data_len:", data_len, 10, HAL_LCD_LINE_6);
    990                     //HalLcdWriteStringValue("recv_value_len:", osal_strlen((char *)recv_value), 10, HAL_LCD_LINE_7); 
    991                     //HalLcdWriteStringValue("data_len_index:", data_len_index, 10, HAL_LCD_LINE_8);
    992                 
    993                     if (data_len_index == data_len) 
    994          	   {
    995          	
    996          		HalSPIWrite(valuechar2[2]*256,recv_value+3,data_len-3);//存储 红外数据长度（长度包括 0XFE+0XFF+编号+长度+红外数据 ）+红外数据
    997          		TRANSFER_DATA_STATE_IN = FALSE;
    998          		//HalLcdWriteStringValue("data_len:", osal_strlen((char *)recv_value), 10, HAL_LCD_LINE_6); 
    999                         // HalLcdWriteStringValue("listlen:", current_list.listlen, 10, HAL_LCD_LINE_8);
   1000          		data_len = 0;
   1001          		cur_data_len = 0;
   1002          		data_len_index = 0;
   1003          		osal_memset(recv_value, 0, data_len);
   1004                          irdata_return[0]=0x11;          
   1005                          SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR5, SIMPLEPROFILE_CHAR5_LEN, irdata_return);
   1006                          
   1007                     }
   1008          
   1009                           break;
   1010                           
   1011          	case SIMPLEPROFILE_CHAR3://接收 编码命令  读取红外码并转发  其实是没有时间戳的 红外命令
   1012          		SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR3, valuechar3);
   1013                         
   1014          		HalSPIRead(valuechar3[0]*256,&datalen_read,1);//读取 红外数据长度  读红外数据、IIC发送时要用到
   1015          		    //延时1S
   1016                         for(i=20; i>0; i--)
   1017                            delay_nus(50);
   1018                          HalSPIRead(valuechar3[0]*256+1,databuf_read,datalen_read-4);//读取 红外数据 	
   1019          		HalLcdWriteString(hex2Str(databuf_read), HAL_LCD_LINE_6);
   1020                          
   1021                           //开始点亮LED
   1022                          P0_4=0;
   1023                         // while(1);
   1024                          for(i=20; i>0; i--)
   1025                            delay_nus(1200);
   1026                          P0_4=1;
   1027                          
   1028          		break;
   1029                  case SIMPLEPROFILE_CHAR4:
   1030                     //  SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR4, newValueBuf);
   1031                    
   1032          		break;
   1033                   case SIMPLEPROFILE_CHAR5://接收完 一条红外代码后  的反馈值
   1034                     
   1035                          SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR5, valuechar5);
   1036                          HalLcdWriteString(hex2Str(valuechar5), HAL_LCD_LINE_7);
   1037                      
   1038          		break;
   1039                   
   1040                  case SIMPLEPROFILE_CHAR6://接收带有时间戳的指令   编码命令+执行时间戳
   1041                    
   1042                        SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR6, valuechar6);
   1043                
   1044                        if(!(peripheral_event&SBP_SEND_IRDATA_EVT1))
   1045          		{	
   1046          			
   1047                                  current_list.value1[0]=valuechar6[0];
   1048                                  current_list.value1[1]=valuechar6[1];
   1049          			osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT1, current_list.value1[1]*1000);
   1050                                  peripheral_event=peripheral_event|SBP_SEND_IRDATA_EVT1;
   1051                                  current_list.listlen++;
   1052                                  HalLcdWriteString("event_1", HAL_LCD_LINE_8);
   1053          			 
   1054          			
   1055          		}
   1056          		else if(!(peripheral_event&SBP_SEND_IRDATA_EVT2))
   1057          		{	
   1058          			
   1059                                  current_list.value2[0]=valuechar6[0];
   1060                                  current_list.value2[1]=valuechar6[1];
   1061          			osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT2, current_list.value2[1]*1000);
   1062                                  peripheral_event=peripheral_event|SBP_SEND_IRDATA_EVT2;
   1063                                  current_list.listlen++;
   1064                                  HalLcdWriteString("event_2", HAL_LCD_LINE_8);
   1065          			
   1066          		}
   1067          		else if(!(peripheral_event&SBP_SEND_IRDATA_EVT3))
   1068          		{
   1069          			current_list.value3[0]=valuechar6[0];
   1070                                  current_list.value3[1]=valuechar6[1];
   1071                                  osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT3, current_list.value3[1]*1000);
   1072                                  peripheral_event=peripheral_event|SBP_SEND_IRDATA_EVT3;
   1073          			current_list.listlen++;
   1074                                  HalLcdWriteString("event_3", HAL_LCD_LINE_8);
   1075          		}
   1076                          else if(!(peripheral_event&SBP_SEND_IRDATA_EVT4))
   1077                            {
   1078                                    current_list.value4[0]=valuechar6[0];
   1079                                    current_list.value4[1]=valuechar6[1];
   1080                                    osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT4, current_list.value4[1]*1000);
   1081                                    peripheral_event=peripheral_event|SBP_SEND_IRDATA_EVT4;
   1082                                    current_list.listlen++;
   1083                                    HalLcdWriteString("event_4", HAL_LCD_LINE_8);
   1084                            }
   1085                          else if(!(peripheral_event&SBP_SEND_IRDATA_EVT5))
   1086                            {
   1087                                    current_list.value5[0]=valuechar6[0];
   1088                                    current_list.value5[1]=valuechar6[1];
   1089                                    osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT5, current_list.value5[1]*1000);
   1090                                    peripheral_event=peripheral_event|SBP_SEND_IRDATA_EVT5;
   1091                                    current_list.listlen++;
   1092                                    HalLcdWriteString("event_5", HAL_LCD_LINE_8);
   1093                            }
   1094          //                else if(!(peripheral_event&SBP_SEND_IRDATA_EVT6))
   1095          //                  {
   1096          //                          current_list.value6[0]=valuechar6[0];
   1097          //                          current_list.value6[1]=valuechar6[1];
   1098          //                          osal_start_timerEx(simpleBLEPeripheral_TaskID, SBP_SEND_IRDATA_EVT6, current_list.value6[1]*1000);
   1099          //                          peripheral_event=peripheral_event|SBP_SEND_IRDATA_EVT6;
   1100          //                          current_list.listlen++;
   1101          //                          HalLcdWriteString("event_6", HAL_LCD_LINE_8);
   1102          //                  }
   1103                        
   1104                       
   1105                           
   1106          		SimpleProfile_SetParameter( SIMPLEPROFILE_CHAR7, SIMPLEPROFILE_CHAR7_LEN, &current_list.listlen);
   1107                     
   1108                          HalLcdWriteStringValue("list_len:", current_list.listlen, 10, HAL_LCD_LINE_2);
   1109                     
   1110          
   1111                        
   1112                    
   1113          		break;
   1114                    case SIMPLEPROFILE_CHAR7:
   1115                      SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR7, valuechar7);
   1116          //             if(valuechar7[0]==0xA2)
   1117          //               {
   1118          //                  
   1119          //                  Batt_MeasLevel();
   1120          //                 
   1121          //               }
   1122          //          
   1123          		break;
   1124                   case SIMPLEPROFILE_CHAR8:
   1125                      SimpleProfile_GetParameter(SIMPLEPROFILE_CHAR8, valuechar8);
   1126           
   1127                       if(valuechar8[0]==0xA1)
   1128                         {
   1129                            // initTempSensor();
   1130                             valuechar8[0]= getTemperature(); 
   1131                             SimpleProfile_SetParameter(SIMPLEPROFILE_CHAR8, SIMPLEPROFILE_CHAR8_LEN, valuechar8);
   1132                             HalLcdWriteString(hex2Str(valuechar8), HAL_LCD_LINE_7);
   1133                         }
   1134          
   1135          	    break;  
   1136                        
   1137          	default:
   1138          		// should not reach here!
   1139          		break;
   1140          	}
   1141          }
   1142          /*********************************************************************
   1143           * @fn      Receive_Save_Uartsend_irdata(void)
   1144           * @brief  if
   1145           * @param  
   1146           * @return  none
   1147           */
   1148          //  static void Receive_Save_Uartsend_irdata(void)
   1149          // {
   1150          //               
   1151          //		
   1152          //	
   1153          //
   1154          //} 
   1155          /*********************************************************************
   1156           * @fn      Uartsend_irdata
   1157           * @brief  
   1158           * @param  
   1159           * @return  none
   1160           */
   1161          // static void Uartsend_irdata()
   1162          // {
   1163          //	        //HalLcdWriteString("ok", HAL_LCD_LINE_5); 
   1164          //		recv_value[UART_DATA_START_INDEX] = 0xE3;
   1165          //                SbpHalUARTWrite(recv_value + UART_DATA_START_INDEX, data_len-4);
   1166          // }
   1167           
   1168          
   1169          /*********************************************************************
   1170           * @fn      bdAddr2Str
   1171           *
   1172           * @brief   Convert Bluetooth address to string. Only needed when
   1173           *          LCD display is used.
   1174           *
   1175           * @return  none
   1176           */
   1177          char *bdAddr2Str(uint8 *pAddr) {
   1178          	uint8 i;
   1179          	char hex[] = "0123456789ABCDEF";
   1180          	static char str[B_ADDR_STR_LEN];
   1181          	char *pStr = str;
   1182          
   1183          	*pStr++ = '0';
   1184          	*pStr++ = 'x';
   1185          
   1186          	// Start from end of addr
   1187          	pAddr += B_ADDR_LEN;
   1188          
   1189          	for (i = B_ADDR_LEN; i > 0; i--) {
   1190          		*pStr++ = hex[*--pAddr >> 4];
   1191          		*pStr++ = hex[*pAddr & 0x0F];
   1192          	}
   1193          
   1194          	*pStr = 0;
   1195          
   1196          	return str;
   1197          }
   1198          char *hex2Str(uint8 *hexcode) {
   1199          	uint8 i;
   1200          	uint8 hexlen;
   1201          	char hex[] = "0123456789ABCDEF";
   1202          	hexlen=osal_strlen((char*)hexcode);
   1203          	static char str[20];
   1204          	char *pStr = str;
   1205          
   1206          	*pStr++ = '0';
   1207          	*pStr++ = 'x';
   1208          
   1209          	// Start from end of addr
   1210          	//pAddr += B_ADDR_LEN;
   1211                  for(i=0;i<hexlen;i++)
   1212          	{
   1213          	  *pStr++ = hex[*hexcode>>4];
   1214                    *pStr++ = hex[*hexcode&0x0F];
   1215                    *hexcode++;
   1216          	 
   1217          	}
   1218          
   1219          	*pStr = 0;
   1220          
   1221          	return str;
   1222          }
   1223          
   1224          /*********************************************************************
   1225           *********************************************************************/
   1226          //static int ascii2hex(char c) {
   1227          //	int ret = -1;
   1228          //	if ((c >= '0') && (c <= '9')) {
   1229          //		ret = c - '0';
   1230          //	} else if ((c >= 'A') && (c <= 'Z')) {
   1231          //		ret = c - 'A' + 65;
   1232          //	} else if ((c >= 'a') && (c <= 'z')) {
   1233          //		ret = c - 'a' + 97;
   1234          //	}
   1235          //	return ret;
   1236          //}
   1237          //static void updateDeviceName(char *name, uint8 len) {
   1238          //	uint8 k = 0;
   1239          //	for (k = 0; k < len; k++) {
   1240          //		scanRspData[k + 2] = ascii2hex(*(name + k));
   1241          //	}
   1242          //}
   1243          
   1244          

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       2      0    142  SimpleBLEPeripheral_Init
                          0 0 142 -> Batt_AddService
                          0 0 142 -> DevInfo_AddService
                          0 0 142 -> GAPRole_SetParameter
                          0 0 142 -> GAP_SetParamValue
                          0 0 142 -> GATTServApp_AddService
                          0 0 142 -> GGS_AddService
                          0 0 142 -> HalAdcInit
                          0 0 142 -> HalLcdWriteString
                          0 0 142 -> RegisterForKeys
                          0 0 142 -> SbpHalUART_Init
                          0 0 142 -> SimpleProfile_AddService
                          0 0 142 -> SimpleProfile_RegisterAppCBs
                          0 0 142 -> SimpleProfile_SetParameter
                          0 0 142 -> osal_set_event
                          0 0 142 -> set_passkey
       0      0     18  SimpleBLEPeripheral_ProcessEvent
                          0 0  14 -> GAPBondMgr_Register
                          0 0  14 -> GAPRole_StartDevice
                          0 0  14 -> HalLcdWriteString
                          0 0  15 -> HalLcdWriteStringValue
                          0 0  18 -> HalSPIRead
                          0 0  14 -> SimpleProfile_SetParameter
                          0 0  14 -> delay_nus
                          0 0  14 -> hex2Str
                          0 0  14 -> osal_msg_deallocate
                          0 0  14 -> osal_msg_receive
                          0 0  14 -> simpleBLEPeripheral_HandleKeys
       2      0     49  bdAddr2Str
       2      0    219  hex2Str
                          0 0  26 -> osal_strlen
       1      0     23  peripheralStateNotificationCB
                          0 0  23 -> DevInfo_SetParameter
                          0 0  23 -> GAPRole_GetParameter
                          0 0  23 -> HalLcdWriteString
                          0 0  23 -> bdAddr2Str
       0      0     12  simpleBLEPeripheralPairStateCB
                          0 0  12 -> GAPRole_TerminateConnection
                          0 0  11 -> HalLcdWriteString
                          0 0  12 -> HalLcdWriteStringValue
       0      0     23  simpleBLEPeripheral_HandleKeys
                          0 0   9 -> HalLcdWriteString
                          0 0   9 -> HalLedSet
                          0 0   9 -> delay_nus
       2      0    197  simpleProfileChangeCB
                          0 0 193 -> HalLcdWriteString
                          0 0 194 -> HalLcdWriteStringValue
                          0 0 197 -> HalSPIRead
                          0 0 197 -> HalSPIWrite
                          0 0 193 -> SimpleProfile_GetParameter
                          0 0 193 -> SimpleProfile_SetParameter
                          0 0 193 -> delay_nus
                          0 0 193 -> getTemperature
                          0 0 193 -> hex2Str
                          0 0 195 -> osal_memcpy
                          0 0 193 -> osal_memset
                          0 0 197 -> osal_start_timerEx
                          0 0 193 -> osal_strlen
                          0 0 193 -> set_code_name


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant " ok">
       1  ?<Constant "">
      17  ?<Constant "0123456789ABCDEF">
      17  ?<Constant "0123456789ABCDEF">_1
      12  ?<Constant "Advertising">
      15  ?<Constant "BLE slave aico">
      16  ?<Constant "Bonding success">
      10  ?<Constant "Connected">
      13  ?<Constant "Disconnected">
       6  ?<Constant "Error">
      12  ?<Constant "Initialized">
      13  ?<Constant "Pairing fail">
      16  ?<Constant "Pairing fail--a">
      16  ?<Constant "Pairing started">
      16  ?<Constant "Pairing success">
      10  ?<Constant "Timed Out">
      14  ?<Constant "cur_data_len:">
      10  ?<Constant "event1 ok">
      10  ?<Constant "event2 ok">
      10  ?<Constant "event3 ok">
      10  ?<Constant "event4 ok">
      10  ?<Constant "event5 ok">
       8  ?<Constant "event_1">
       8  ?<Constant "event_2">
       8  ?<Constant "event_3">
       8  ?<Constant "event_4">
       8  ?<Constant "event_5">
      10  ?<Constant "list_len:">
       8  ?<Constant "long ok">
      20  ?<Constant {0}>
      20  ?<Constant {0}>_1
      20  ?<Constant {0}>_10
      20  ?<Constant {0}>_11
      20  ?<Constant {0}>_12
      20  ?<Constant {0}>_13
      20  ?<Constant {0}>_14
      20  ?<Constant {0}>_2
      20  ?<Constant {0}>_3
      20  ?<Constant {0}>_4
      20  ?<Constant {0}>_5
      20  ?<Constant {0}>_6
      20  ?<Constant {0}>_7
      20  ?<Constant {0}>_8
      20  ?<Constant {0}>_9
       7  ?<Initializer for advertData>
      13  ?<Initializer for current_list>
      30  ?<Initializer for scanRspData>
       4  ?<Initializer for simpleBLEPeripheral_BondMgrC
       4  ?<Initializer for simpleBLEPeripheral_Peripher
       2  ?<Initializer for simpleBLEPeripheral_SimplePr
       6  ??SimpleBLEPeripheral_Init?relay
       6  ??SimpleBLEPeripheral_ProcessEvent?relay
       3  ??Subroutine14_0
       5  ??Subroutine15_0
       6  ??bdAddr2Str?relay
       6  ??hex2Str?relay
       6  ??peripheralStateNotificationCB?relay
       6  ??simpleBLEPeripheralPairStateCB?relay
       6  ??simpleBLEPeripheral_HandleKeys?relay
       6  ??simpleProfileChangeCB?relay
       2  ?Subroutine0
      31  ?Subroutine1
      10  ?Subroutine10
      13  ?Subroutine11
      13  ?Subroutine12
      16  ?Subroutine13
      15  ?Subroutine2
      10  ?Subroutine3
      14  ?Subroutine4
      11  ?Subroutine5
      16  ?Subroutine6
      14  ?Subroutine7
       8  ?Subroutine8
       7  ?Subroutine9
       1  P0DIR
       1  P0SEL
       1  P1DIR
       1  P1SEL
       1  P2SEL
       1  PERCFG
     667  SimpleBLEPeripheral_Init
     845  SimpleBLEPeripheral_ProcessEvent
       1  TRANSFER_DATA_STATE_IN
       1  U1BAUD
       1  U1GCR
       1  _A_P0
       1  _A_P1
       1  _A_U1CSR
       4  __Constant_ffffffff
       7  advertData
      99  bdAddr2Str
      20  buf
      20  bufrx
       1  cur_data_len
      13  current_list
       1  data_len
       1  data_len_index
       2  gapConnHandle
       1  gapProfileState
     109  hex2Str
     306  peripheralStateNotificationCB
       2  peripheral_event
     128  recv_value
      30  scanRspData
     115  simpleBLEPeripheralPairStateCB
       4  simpleBLEPeripheral_BondMgrCBs
     120  simpleBLEPeripheral_HandleKeys
       4  simpleBLEPeripheral_PeripheralCBs
       2  simpleBLEPeripheral_SimpleProfileCBs
       1  simpleBLEPeripheral_TaskID
    1243  simpleProfileChangeCB
      15  str
      20  str
      10  temp_18b20
       1  temp_18b20_flag
       1  temp_flag
      20  temperature
      20  time_databuf_read
       1  time_datalen_read

 
 3 692 bytes in segment BANKED_CODE
    48 bytes in segment BANK_RELAYS
    11 bytes in segment SFR_AN
    60 bytes in segment XDATA_I
    60 bytes in segment XDATA_ID
   620 bytes in segment XDATA_ROM_C
   266 bytes in segment XDATA_Z
 
 3 800 bytes of CODE  memory
   616 bytes of CONST memory (+  4 bytes shared)
     0 bytes of DATA  memory (+ 11 bytes shared)
   326 bytes of XDATA memory

Errors: none
Warnings: 2
