###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.20.2.41139 for 8051             28/Feb/2014  16:48:43 #
# Copyright 2004-2013 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#                                                                             #
#    Source file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Components\os #
#                          al\mcu\cc2540\osal_snv.c                           #
#    Command line       =  -f E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\config\b #
#                          uildComponents.cfg (-DBROADCASTER_CFG=0x01         #
#                          -DOBSERVER_CFG=0x02 -DPERIPHERAL_CFG=0x04          #
#                          -DCENTRAL_CFG=0x08 -DADV_NCONN_CFG=0x01            #
#                          -DADV_CONN_CFG=0x02 -DSCAN_CFG=0x04                #
#                          -DINIT_CFG=0x08 -DADV_CFG=ADV_NCONN_CFG+ADV_CONN_C #
#                          FG -DLINK_CFG=ADV_CONN_CFG+INIT_CFG                #
#                          -DFULL_CFG=INIT_CFG+SCAN_CFG+ADV_NCONN_CFG+ADV_CON #
#                          N_CFG) -f E:\TexasInstruments\BLE-CC254x-1.4.0\Pro #
#                          jects\ble\SimpleBLEPeripheralzeke\CC2541DB\buildCo #
#                          nfig.cfg (-DHOST_CONFIG=PERIPHERAL_CFG             #
#                          -DGAP_PRIVACY_RECONNECT -DCC2541                   #
#                          -DOAD_IMAGE_VERSION=0x0000                         #
#                          "-DOAD_IMAGE_A_USER_ID='A', 'A', 'A', 'A'"         #
#                          "-DOAD_IMAGE_B_USER_ID='B', 'B', 'B', 'B'")        #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Components\os #
#                          al\mcu\cc2540\osal_snv.c -D INT_HEAP_LEN=3074 -D   #
#                          HALNODEBUG -D OSAL_CBTIMER_NUM_TASKS=1 -D          #
#                          HAL_AES_DMA=TRUE -D HAL_DMA=TRUE -D POWER_SAVING   #
#                          -D xPLUS_BROADCASTER -D HAL_LCD=TRUE -D            #
#                          HAL_LED=TRUE -D HAL_UART=TRUE -lcN                 #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\ -o   #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\ -e    #
#                          --debug --core=plain --dptr=16,1                   #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\common\  #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\include\ #
#                           -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ #
#                          ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\C #
#                          omponents\hal\include\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\hal\target\CC2541EB\ -I                      #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\osal\include\ -I E:\TexasInstruments\BLE-CC2 #
#                          54x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2 #
#                          541DB\..\..\..\..\Components\services\saddr\ -I    #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\include\ -I E:\TexasInstruments\BLE-CC25 #
#                          4x-1.4.0\Projects\ble\SimpleBLEPeripheralzeke\CC25 #
#                          41DB\..\..\..\..\Components\ble\controller\phy\    #
#                          -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\b #
#                          le\SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Co #
#                          mponents\ble\controller\include\ -I                #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\..\..\Compo #
#                          nents\ble\hci\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\..\..\Components\ble\host\ -I               #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\common\cc25 #
#                          40\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\comm #
#                          on\npi\npi_np\ -I E:\TexasInstruments\BLE-CC254x-1 #
#                          .4.0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB #
#                          \..\..\Profiles\Roles\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Si #
#                          mpleProfile\ -I E:\TexasInstruments\BLE-CC254x-1.4 #
#                          .0\Projects\ble\SimpleBLEPeripheralzeke\CC2541DB\. #
#                          .\..\Profiles\DevInfo\ -I                          #
#                          E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\..\..\Profiles\Ba #
#                          tt\ -I E:\TexasInstruments\BLE-CC254x-1.4.0\Projec #
#                          ts\ble\SimpleBLEPeripheralzeke\CC2541DB\..\..\Prof #
#                          iles\HIDDev\ -Ohz                                  #
#    List file          =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\List\osal_ #
#                          snv.lst                                            #
#    Object file        =  E:\TexasInstruments\BLE-CC254x-1.4.0\Projects\ble\ #
#                          SimpleBLEPeripheralzeke\CC2541DB\CC2541\Obj\osal_s #
#                          nv.r51                                             #
#                                                                             #
#                                                                             #
###############################################################################

E:\TexasInstruments\BLE-CC254x-1.4.0\Components\osal\mcu\cc2540\osal_snv.c
      1          /**************************************************************************************************
      2            Filename:       osal_snv.c
      3            Revised:        $Date: 2013-02-15 10:12:26 -0800 (Fri, 15 Feb 2013) $
      4            Revision:       $Revision: 33143 $
      5          
      6            Description:    This module contains the OSAL simple non-volatile memory functions.
      7          
      8          
      9            Copyright 2009-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41           * INCLUDES
     42           */
     43          
     44          #include "hal_adc.h"
     45          #include "hal_flash.h"
     46          #include "hal_types.h"
     47          #include "comdef.h"
     48          #include "OSAL.h"
     49          #include "osal_snv.h"
     50          #include "hal_assert.h"
     51          #include "saddr.h"
     52          
     53          #ifdef OSAL_SNV_UINT16_ID
     54          # error "This OSAL SNV implementation does not support the extended ID space"
     55          #endif
     56          
     57          /*********************************************************************
     58           * CONSTANTS
     59           */
     60          
     61          // NV page configuration
     62          #define OSAL_NV_PAGE_SIZE       HAL_FLASH_PAGE_SIZE
     63          #define OSAL_NV_PAGES_USED      HAL_NV_PAGE_CNT
     64          #define OSAL_NV_PAGE_BEG        HAL_NV_PAGE_BEG
     65          #define OSAL_NV_PAGE_END       (OSAL_NV_PAGE_BEG + OSAL_NV_PAGES_USED - 1)
     66          
     67          // Default byte value when flash is erased
     68          #define OSAL_NV_ERASED          0xFF
     69          
     70          // NV page header size in bytes
     71          #define OSAL_NV_PAGE_HDR_SIZE  4
     72          
     73          // In case pages 0-1 are ever used, define a null page value.
     74          #define OSAL_NV_PAGE_NULL       0
     75          
     76          // In case item Id 0 is ever used, define a null item value.
     77          #define OSAL_NV_ITEM_NULL       0
     78          
     79          // Length in bytes of a flash word
     80          #define OSAL_NV_WORD_SIZE       HAL_FLASH_WORD_SIZE
     81          
     82          // NV page header offset within a page
     83          #define OSAL_NV_PAGE_HDR_OFFSET 0
     84          
     85          
     86          // Flag in a length field of an item header to indicate validity
     87          // of the length field
     88          #define OSAL_NV_INVALID_LEN_MARK 0x8000
     89          
     90          // Flag in an ID field of an item header to indicate validity of
     91          // the identifier field
     92          #define OSAL_NV_INVALID_ID_MARK  0x8000
     93          
     94          
     95          // Bit difference between active page state indicator value and
     96          // transfer page state indicator value
     97          #define OSAL_NV_ACTIVE_XFER_DIFF  0x00100000
     98          
     99          // active page state indicator value
    100          #define OSAL_NV_ACTIVE_PAGE_STATE OSAL_NV_ACTIVE_XFER_DIFF
    101          
    102          // transfer page state indicator value
    103          #define OSAL_NV_XFER_PAGE_STATE   (OSAL_NV_ACTIVE_PAGE_STATE ^ OSAL_NV_ACTIVE_XFER_DIFF)
    104          
    105          #define OSAL_NV_MIN_COMPACT_THRESHOLD   70 // Minimum compaction threshold
    106          #define OSAL_NV_MAX_COMPACT_THRESHOLD   95 // Maximum compaction threshold
    107          
    108          /*********************************************************************
    109           * MACROS
    110           */
    111          
    112          // Macro to check supply voltage
    113          #if (defined HAL_MCU_CC2530 || defined HAL_MCU_CC2531)
    114          # define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalAdcCheckVdd(VDD_MIN_FLASH))
    115          #elif defined HAL_MCU_CC2533
    116          # define  OSAL_NV_CHECK_BUS_VOLTAGE  (HalBatMonRead( HAL_BATMON_MIN_FLASH ))
    117          #else
    118          // The radio chip does not support voltage monitoring
    119          # define  OSAL_NV_CHECK_BUS_VOLTAGE TRUE
    120          #endif
    121          
    122          /*********************************************************************
    123           * TYPEDEFS
    124           */
    125          
    126          // NV item header structure
    127          typedef struct
    128          {
    129            uint16 id;
    130            uint16 len;
    131          } osalNvItemHdr_t;
    132          // Note that osalSnvId_t and osalSnvLen_t cannot be bigger than uint16
    133          
    134          /*********************************************************************
    135           * EXTERNAL FUNCTIONS
    136           */
    137          
    138          extern bool HalAdcCheckVdd(uint8 limit);
    139          
    140          /*********************************************************************
    141           * GLOBAL VARIABLES
    142           */
    143          
    144          #ifndef OAD_KEEP_NV_PAGES
    145          // When NV pages are to remain intact during OAD download,
    146          // the image itself should not include NV pages.
    147          #pragma location="BLENV_ADDRESS_SPACE"
    148          __no_init uint8 _nvBuf[OSAL_NV_PAGES_USED * OSAL_NV_PAGE_SIZE];
    149          #pragma required=_nvBuf
    150          #endif // OAD_KEEP_NV_PAGES
    151          
    152          #if defined MAKE_CRC_SHDW
    153          #pragma location="CRC_SHDW"
    154          const CODE uint16 _crcShdw = 0xFFFF;
    155          #pragma required=_crcShdw
    156          #endif
    157          
    158          /*********************************************************************
    159           * LOCAL VARIABLES
    160           */
    161          
    162          // active page
    163          static uint8 activePg;
    164          
    165          // active page offset
    166          static uint16 pgOff;
    167          
    168          // flag to indicate that an error has occurred while writing to or erasing the
    169          // flash device. Once this flag indicates failure, it is unsafe to attempt
    170          // another write or erase.
    171          static uint8 failF;
    172          
    173          /*********************************************************************
    174           * LOCAL FUNCTIONS
    175           */
    176          
    177          static uint8  initNV( void );
    178          
    179          static void   setActivePage( uint8 pg );
    180          static void   setXferPage(void);
    181          static void   erasePage( uint8 pg );
    182          static void   cleanErasedPage( uint8 pg );
    183          static void   findOffset( void );
    184          static void   compactPage( uint8 pg );
    185          
    186          static void   writeWord( uint8 pg, uint16 offset, uint8 *pBuf );
    187          static void   writeWordM( uint8 pg, uint16 offset, uint8 *pBuf, osalSnvLen_t cnt );
    188          
    189          
    190          // NOTE: Triggering erase upon power up may cause fast aging of the flash device
    191          //       if there is power switch debounce issue, etc.
    192          //       Improvement of this is to add a certain delay upon power up before
    193          //       osal_nv_init() is called.
    194          
    195          /*********************************************************************
    196           * @fn      initNV
    197           *
    198           * @brief   Initialize the NV flash pages.
    199           *
    200           * @param   none
    201           *
    202           * @return  TRUE if initialization succeeds. FALSE, otherwise.
    203           */
    204          static uint8 initNV( void )
    205          {
    206            uint32 pgHdr;
    207            uint8 xferPg = OSAL_NV_PAGE_NULL;
    208            uint8 pg;
    209          
    210            failF = FALSE;
    211            activePg = OSAL_NV_PAGE_NULL;
    212          
    213            // Pick active page and clean up erased page if necessary
    214            for ( pg = OSAL_NV_PAGE_BEG; pg <= OSAL_NV_PAGE_END; pg++ )
    215            {
    216              HalFlashRead(pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8 *)(&pgHdr), OSAL_NV_PAGE_HDR_SIZE);
    217          
    218              if ( pgHdr == OSAL_NV_ACTIVE_PAGE_STATE)
    219              {
    220                if (activePg != OSAL_NV_PAGE_NULL)
    221                {
    222                  // Both pages are active only when power failed during flash erase and
    223                  // with very low probability.
    224                  // As it is hard (code size intensive) to figure out which page is the real active page,
    225                  // and theoretically impossible as well in lowest probability, erase both pages
    226                  // in this case
    227                  cleanErasedPage(activePg);
    228                  cleanErasedPage(pg);
    229                  activePg = OSAL_NV_PAGE_NULL;
    230                }
    231                else
    232                {
    233                  activePg = pg;
    234                }
    235              }
    236              else if ( pgHdr == OSAL_NV_XFER_PAGE_STATE)
    237              {
    238                xferPg = pg;
    239              }
    240              else
    241              {
    242                // Erase this page if it is not erased.
    243                // This is to ensure that any page that were in the middle of
    244                // compacting gets erased.
    245                cleanErasedPage(pg);
    246              }
    247            }
    248          
    249            if (activePg == OSAL_NV_PAGE_NULL)
    250            {
    251              if (xferPg == OSAL_NV_PAGE_NULL)
    252              {
    253                // Both pages are erased. This must be initial state.
    254                // Pick one page as active page.
    255                setActivePage(OSAL_NV_PAGE_BEG);
    256                pgOff = OSAL_NV_PAGE_HDR_SIZE;
    257          
    258                // If setting active page from a completely erased page failed,
    259                // it is not recommended to operate any further.
    260                // Other cases, even if non-active page is corrupt, NV module can still read
    261                // the active page content and hence this function could return TRUE.
    262                return (!failF);
    263              }
    264              else
    265              {
    266                // Compacting a page hasn't completed in previous power cycle.
    267                // Complete the compacting.
    268                activePg = xferPg;
    269                findOffset();
    270          
    271                compactPage(xferPg);
    272              }
    273            }
    274            else
    275            {
    276              if (xferPg != OSAL_NV_PAGE_NULL)
    277              {
    278                // Compacting has completed except for the final step of erasing
    279                // the xferPage.
    280                erasePage(xferPg);
    281              }
    282          
    283              // find the active page offset to write a new variable location item
    284              findOffset();
    285            }
    286          
    287            return TRUE;
    288          }
    289          
    290          /*********************************************************************
    291           * @fn      setActivePage
    292           *
    293           * @brief   Set page header active state to be active.
    294           *
    295           * @param   pg - Valid NV page to activate.
    296           *
    297           * @return  none
    298           */
    299          static void setActivePage( uint8 pg )
    300          {
    301            uint32 pgHdr;
    302          
    303            pgHdr = OSAL_NV_ACTIVE_PAGE_STATE;
    304          
    305            writeWord( pg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*) &pgHdr );
    306            if (!failF)
    307            {
    308              activePg = pg;
    309            }
    310          }
    311          
    312          /*********************************************************************
    313           * @fn      setXferPage
    314           *
    315           * @brief   Set active page header state to be transfer state.
    316           *
    317           * @param   none
    318           *
    319           * @return  none
    320           */
    321          static void setXferPage(void)
    322          {
    323            uint32 pgHdr;
    324          
    325            // erase difference bit between active state and xfer state
    326            pgHdr = OSAL_NV_XFER_PAGE_STATE;
    327          
    328            writeWord( activePg, OSAL_NV_PAGE_HDR_OFFSET, (uint8*)&pgHdr );
    329          }
    330          
    331          /*********************************************************************
    332           * @fn      erasePage
    333           *
    334           * @brief   Erases a page in Flash.
    335           *
    336           * @param   pg - Valid NV page to erase.
    337           *
    338           * @return  none
    339           */
    340          static void erasePage( uint8 pg )
    341          {
    342            if ( !OSAL_NV_CHECK_BUS_VOLTAGE || failF)
    343            {
    344              failF = TRUE;
    345              return;
    346            }
    347          
    348            HalFlashErase(pg);
    349          
    350            {
    351              // Verify the erase operation
    352              uint16 offset;
    353              uint8 tmp;
    354          
    355              for (offset = 0; offset < OSAL_NV_PAGE_SIZE; offset ++)
    356              {
    357                HalFlashRead(pg, offset, &tmp, 1);
    358                if (tmp != OSAL_NV_ERASED)
    359                {
    360                  failF = TRUE;
    361                  break;
    362                }
    363              }
    364            }
    365          }
    366          
    367          /*********************************************************************
    368           * @fn      cleanErasedPage
    369           *
    370           * @brief   Erases a page in Flash if the page is not completely erased.
    371           *
    372           * @param   pg - Valid NV page to erase.
    373           *
    374           * @return  none
    375           */
    376          static void cleanErasedPage( uint8 pg )
    377          {
    378            uint8 buf;
    379            uint16 offset;
    380          
    381            for (offset = 0; offset < OSAL_NV_PAGE_SIZE; offset ++)
    382            {
    383              HalFlashRead(pg, offset, &buf, 1);
    384              if (buf != OSAL_NV_ERASED)
    385              {
    386                erasePage(pg);
    387                break;
    388              }
    389            }
    390          }
    391          
    392          /*********************************************************************
    393           * @fn      findOffset
    394           *
    395           * @brief   find an offset of an empty space in active page
    396           *          where to write a new item to.
    397           *
    398           * @param   None
    399           *
    400           * @return  none
    401           */
    402          static void findOffset(void)
    403          {
    404            uint16 offset;
    405            for (offset = OSAL_NV_PAGE_SIZE - OSAL_NV_WORD_SIZE;
    406                 offset >= OSAL_NV_PAGE_HDR_SIZE;
    407                 offset -= OSAL_NV_WORD_SIZE)
    408            {
    409              uint32 tmp;
    410          
    411              HalFlashRead(activePg, offset, (uint8 *)&tmp, OSAL_NV_WORD_SIZE);
    412              if (tmp != 0xFFFFFFFF)
    413              {
    414                break;
    415              }
    416            }
    417            pgOff = offset + OSAL_NV_WORD_SIZE;
    418          }
    419          
    420          /*********************************************************************
    421           * @fn      findItem
    422           *
    423           * @brief   find a valid item from a designated page and offset
    424           *
    425           * @param   pg       - NV page
    426           * @param   offset   - offset in the NV page from where to start
    427           *                     search up.
    428           *                     Usually this paramter is set to the empty space
    429           *                     offset.
    430           * @param   id       - NV item ID to search for
    431           *
    432           * @return  offset of the item, 0 when not found
    433           */
    434          static uint16 findItem(uint8 pg, uint16 offset, osalSnvId_t id)
    435          {
    436            offset -= OSAL_NV_WORD_SIZE;
    437          
    438            while (offset >= OSAL_NV_PAGE_HDR_SIZE)
    439            {
    440              osalNvItemHdr_t hdr;
    441          
    442              HalFlashRead(pg, offset, (uint8 *) &hdr, OSAL_NV_WORD_SIZE);
    443          
    444              if (hdr.id == id)
    445              {
    446                // item found
    447                // length field could be corrupt. Mask invalid length mark.
    448                uint8 len = hdr.len & ~OSAL_NV_INVALID_LEN_MARK;
    449                return offset - len;
    450              }
    451              else if (hdr.len & OSAL_NV_INVALID_LEN_MARK)
    452              {
    453                offset -= OSAL_NV_WORD_SIZE;
    454              }
    455              else
    456              {
    457                // valid length field
    458                if (hdr.len + OSAL_NV_WORD_SIZE <= offset)
    459                {
    460                  // valid length
    461                  offset -= hdr.len + OSAL_NV_WORD_SIZE;
    462                }
    463                else
    464                {
    465                  // active page is corrupt
    466                  // This could happen if NV initialization failed upon failure to erase
    467                  // page and active page is set to uncleanly erased page.
    468                  HAL_ASSERT_FORCED();
    469                  return 0;
    470                }
    471              }
    472            }
    473            return 0;
    474          }
    475          
    476          /*********************************************************************
    477           * @fn      writeItem
    478           *
    479           * @brief   Write a data item to NV. Function can write an entire item to NV
    480           *
    481           * @param   pg     - Page number
    482           * @param   offset - offset within the NV page where to write the new item
    483           * @param   id     - NV item ID
    484           * @param   alignedLen - Length of data to write, alinged in flash word
    485           *                       boundary
    486           * @param  *pBuf   - Data to write.
    487           *
    488           * @return  none
    489           */
    490          static void writeItem( uint8 pg, uint16 offset, osalSnvId_t id, uint16 alignedLen, uint8 *pBuf )
    491          {
    492            osalNvItemHdr_t hdr;
    493          
    494            hdr.id = 0xFFFF;
    495            hdr.len = alignedLen | OSAL_NV_INVALID_LEN_MARK;
    496          
    497            // Write the len portion of the header first
    498            writeWord(pg, offset + alignedLen, (uint8 *) &hdr);
    499          
    500            // remove invalid len mark
    501            hdr.len &= ~OSAL_NV_INVALID_LEN_MARK;
    502            writeWord(pg, offset + alignedLen, (uint8 *) &hdr);
    503          
    504            // Copy over the data
    505            writeWordM(pg, offset, pBuf, alignedLen / OSAL_NV_WORD_SIZE);
    506          
    507            // value is valid. Write header except for the most significant bit.
    508            hdr.id = id | OSAL_NV_INVALID_ID_MARK;
    509            writeWord(pg, offset + alignedLen, (uint8 *) &hdr);
    510          
    511            // write the most significant bit
    512            hdr.id &= ~OSAL_NV_INVALID_ID_MARK;
    513            writeWord(pg, offset + alignedLen, (uint8 *) &hdr);
    514          }
    515          
    516          /*********************************************************************
    517           * @fn      xferItem
    518           *
    519           * @brief   Copy an NV item from the active page to a designated page.
    520           *
    521           * @param   pg         - NV page where to copy the item to.
    522           * @param   offset     - NV page offset where to copy the item to.
    523           * @param   alignedLen - Length of data to write, aligned in flash word
    524           *                       boundary.
    525           * @param   srcOff     - NV page offset of the original data in active page
    526           *
    527           * @return  none.
    528           */
    529          static void xferItem( uint8 pg, uint16 offset, uint16 alignedLen, uint16 srcOff )
    530          {
    531            uint8 tmp[OSAL_NV_WORD_SIZE];
    532            uint16 i = 0;
    533          
    534            // Copy over the data
    535            while (i <= alignedLen)
    536            {
    537              HalFlashRead(activePg, srcOff + i, tmp, OSAL_NV_WORD_SIZE);
    538              writeWord(pg, offset + i, tmp);
    539          
    540              i += OSAL_NV_WORD_SIZE;
    541            }
    542          }
    543          
    544          /*********************************************************************
    545           * @fn      compactPage
    546           *
    547           * @brief   Compacts the page specified.
    548           *
    549           * @param   srcPg - Valid NV page to compact from.
    550           *                  The page must have changed its state (header) to xfer state
    551           *                  prior to this function call. This function will not
    552           *                  modify the state of its header to xfer state before starting
    553           *                  to compact.
    554           *
    555           * @return  none.
    556           */
    557          static void compactPage( uint8 srcPg )
    558          {
    559            uint16 srcOff, dstOff;
    560            uint8 dstPg;
    561            osalSnvId_t lastId = (osalSnvId_t) 0xFFFF;
    562          
    563            dstPg = (srcPg == OSAL_NV_PAGE_BEG)? OSAL_NV_PAGE_END : OSAL_NV_PAGE_BEG;
    564          
    565            dstOff = OSAL_NV_PAGE_HDR_SIZE;
    566          
    567            // Read from the latest value
    568            srcOff = pgOff - sizeof(osalNvItemHdr_t);
    569          
    570            while (srcOff >= OSAL_NV_PAGE_HDR_SIZE)
    571            {
    572              osalNvItemHdr_t hdr;
    573          
    574              if (failF)
    575              {
    576                // Failure during transfer item will make next findItem error prone.
    577                return;
    578              }
    579          
    580              HalFlashRead(srcPg, srcOff, (uint8 *) &hdr, OSAL_NV_WORD_SIZE);
    581          
    582              if (hdr.id == 0xFFFF)
    583              {
    584                // Invalid entry. Skip this one.
    585                if (hdr.len & OSAL_NV_INVALID_LEN_MARK)
    586                {
    587                  srcOff -= OSAL_NV_WORD_SIZE;
    588                }
    589                else
    590                {
    591                  if (hdr.len + OSAL_NV_WORD_SIZE <= srcOff)
    592                  {
    593                    srcOff -= hdr.len + OSAL_NV_WORD_SIZE;
    594                  }
    595                  else
    596                  {
    597                    // invalid length. Source page must be a corrupt page.
    598                    // This is possible only if the NV initialization failed upon erasing
    599                    // what is selected as active page.
    600                    // This is supposed to be a very rare case, as power should be
    601                    // shutdown exactly during erase and then the page header is
    602                    // still retained as either the Xfer or the Active state.
    603          
    604                    // For production code, it might be useful to attempt to erase the page
    605                    // so that at next power cycle at least the device is runnable
    606                    // (with all entries removed).
    607                    // However, it might be still better not to attempt erasing the page
    608                    // just to see if this very rare case actually happened.
    609                    //erasePage(srcPg);
    610          
    611                    HAL_ASSERT_FORCED();
    612                    return;
    613                  }
    614                }
    615          
    616                continue;
    617              }
    618          
    619              // Consider only valid item
    620              if (!(hdr.id & OSAL_NV_INVALID_ID_MARK) && hdr.id != lastId)
    621              {
    622                // lastId is used to speed up compacting in case the same item ID
    623                // items were neighboring each other contiguously.
    624                lastId = (osalSnvId_t) hdr.id;
    625          
    626                // Check if the latest value of the item was already written
    627                if (findItem(dstPg, dstOff, lastId) == 0)
    628                {
    629                  // This item was not copied over yet.
    630                  // This must be the latest value.
    631                  // Write the latest value to the destination page
    632          
    633                  xferItem(dstPg, dstOff, hdr.len, srcOff - hdr.len);
    634          
    635                  dstOff += hdr.len + OSAL_NV_WORD_SIZE;
    636                }
    637              }
    638              srcOff -= hdr.len + OSAL_NV_WORD_SIZE;
    639            }
    640          
    641            // All items copied.
    642            // Activate the new page
    643            setActivePage(dstPg);
    644          
    645            if (!failF)
    646            {
    647              pgOff = dstOff; // update active page offset
    648            }
    649          
    650            // Erase the currently active page
    651            erasePage(srcPg);
    652          }
    653          
    654          /*********************************************************************
    655           * @fn      verifyWordM
    656           *
    657           * @brief   verify the written word.
    658           *
    659           * @param   pg - A valid NV Flash page.
    660           * @param   offset - A valid offset into the page.
    661           * @param   pBuf - Pointer to source buffer.
    662           * @param   cnt - Number of 4-byte blocks to verify.
    663           *
    664           * @return  none
    665           */
    666          static void verifyWordM( uint8 pg, uint16 offset, uint8 *pBuf, osalSnvLen_t cnt )
    667          {
    668            uint8 tmp[OSAL_NV_WORD_SIZE];
    669          
    670            while (cnt--)
    671            {
    672              // Reading byte per byte will reduce code size but will slow down
    673              // and not sure it will meet the timing requirements.
    674              HalFlashRead(pg, offset, tmp, OSAL_NV_WORD_SIZE);
    675              if (FALSE == osal_memcmp(tmp, pBuf, OSAL_NV_WORD_SIZE))
    676              {
    677                failF = TRUE;
    678                return;
    679              }
    680              offset += OSAL_NV_WORD_SIZE;
    681              pBuf += OSAL_NV_WORD_SIZE;
    682            }
    683          }
    684          
    685          /*********************************************************************
    686           * @fn      writeWord
    687           *
    688           * @brief   Writes a Flash-WORD to NV.
    689           *
    690           * @param   pg - A valid NV Flash page.
    691           * @param   offset - A valid offset into the page.
    692           * @param   pBuf - Pointer to source buffer.
    693           *
    694           * @return  none
    695           */
    696          static void writeWord( uint8 pg, uint16 offset, uint8 *pBuf )
    697          {
    698            uint16 addr = (offset >> 2) + ((uint16)pg << 9);
    699          
    700            if ( !failF )
    701            {
    702              HalFlashWrite(addr, pBuf, 1);
    703              verifyWordM(pg, offset, pBuf, 1);
    704            }
    705          }
    706          
    707          /*********************************************************************
    708           * @fn      writeWordM
    709           *
    710           * @brief   Writes multiple Flash-WORDs to NV.
    711           *
    712           * @param   pg - A valid NV Flash page.
    713           * @param   offset - A valid offset into the page.
    714           * @param   buf - Pointer to source buffer.
    715           * @param   cnt - Number of 4-byte blocks to write.
    716           *
    717           * @return  none
    718           */
    719          static void writeWordM( uint8 pg, uint16 offset, uint8 *buf, osalSnvLen_t cnt )
    720          {
    721            uint16 addr = (offset >> 2) + ((uint16)pg << 9);
    722          
    723            if ( !failF )
    724            {
    725              HalFlashWrite(addr, buf, cnt);
    726              verifyWordM(pg, offset, buf, cnt);
    727            }
    728          }
    729          
    730          /*********************************************************************
    731           * @fn      osal_snv_init
    732           *
    733           * @brief   Initialize NV service.
    734           *
    735           * @return  SUCCESS if initialization succeeds. FAILURE, otherwise.
    736           */
    737          uint8 osal_snv_init( void )
    738          {
    739            if (!initNV())
    740            {
    741              // NV initialization failed
    742              HAL_ASSERT_FORCED();
    743          
    744              return FAILURE;
    745            }
    746          
    747            return SUCCESS;
    748          }
    749          
    750          /*********************************************************************
    751           * @fn      osal_snv_write
    752           *
    753           * @brief   Write a data item to NV.
    754           *
    755           * @param   id  - Valid NV item Id.
    756           * @param   len - Length of data to write.
    757           * @param   *pBuf - Data to write.
    758           *
    759           * @return  SUCCESS if successful, NV_OPER_FAILED if failed.
    760           */
    761          uint8 osal_snv_write( osalSnvId_t id, osalSnvLen_t len, void *pBuf )
    762          {
    763            uint16 alignedLen;
    764          
    765            {
    766              uint16 offset = findItem(activePg, pgOff, id);
    767          
    768              if (offset > 0)
    769              {
    770                uint8 tmp;
    771                osalSnvLen_t i;
    772          
    773                for (i = 0; i < len; i++)
    774                {
    775                  HalFlashRead(activePg, offset, &tmp, 1);
    776                  if (tmp != ((uint8 *)pBuf)[i])
    777                  {
    778                    break;
    779                  }
    780                  offset++;
    781                }
    782          
    783                if (i == len)
    784                {
    785                  // Changed value is the same value as before.
    786                  // Return here instead of re-writing the same value to NV.
    787                  return SUCCESS;
    788                }
    789              }
    790            }
    791          
    792            alignedLen = ((len + OSAL_NV_WORD_SIZE - 1) / OSAL_NV_WORD_SIZE) * OSAL_NV_WORD_SIZE;
    793          
    794            if ( pgOff + alignedLen + OSAL_NV_WORD_SIZE > OSAL_NV_PAGE_SIZE )
    795            {
    796              setXferPage();
    797              compactPage(activePg);
    798            }
    799          
    800            // pBuf shall be referenced beyond its valid length to save code size.
    801            writeItem(activePg, pgOff, id, alignedLen, pBuf);
    802            if (failF)
    803            {
    804              return NV_OPER_FAILED;
    805            }
    806          
    807            pgOff += alignedLen + OSAL_NV_WORD_SIZE;
    808          
    809            return SUCCESS;
    810          }
    811          
    812          /*********************************************************************
    813           * @fn      osal_snv_read
    814           *
    815           * @brief   Read data from NV.
    816           *
    817           * @param   id  - Valid NV item Id.
    818           * @param   len - Length of data to read.
    819           * @param   *pBuf - Data is read into this buffer.
    820           *
    821           * @return  SUCCESS if successful.
    822           *          Otherwise, NV_OPER_FAILED for failure.
    823           */
    824          uint8 osal_snv_read( osalSnvId_t id, osalSnvLen_t len, void *pBuf )
    825          {
    826            uint16 offset = findItem(activePg, pgOff, id);
    827          
    828            if (offset != 0)
    829            {
    830              HalFlashRead(activePg, offset, pBuf, len);
    831              return SUCCESS;
    832            }
    833            return NV_OPER_FAILED;
    834          }
    835          
    836          /*********************************************************************
    837           * @fn      osal_snv_compact
    838           *
    839           * @brief   Compacts NV if its usage has reached a specific threshold.
    840           *
    841           * @param   threshold - compaction threshold
    842           *
    843           * @return  SUCCESS if successful,
    844           *          NV_OPER_FAILED if failed, or
    845           *          INVALIDPARAMETER if threshold invalid.
    846           */
    847          uint8 osal_snv_compact( uint8 threshold )
    848          {
    849            if ( ( threshold < OSAL_NV_MIN_COMPACT_THRESHOLD ) ||
    850                 ( threshold > OSAL_NV_MAX_COMPACT_THRESHOLD ) )
    851            {
    852              return INVALIDPARAMETER;
    853            }
    854          
    855            // See if NV active page usage has reached compaction threshold
    856            if ( ( (uint32)pgOff * 100 ) >= ( OSAL_NV_PAGE_SIZE * (uint32)threshold ) )
    857            {
    858              setXferPage();
    859              compactPage(activePg);
    860          
    861              return SUCCESS;
    862            }
    863          
    864            return NV_OPER_FAILED;
    865          }
    866          
    867          /*********************************************************************
    868          *********************************************************************/

   Maximum stack usage in bytes:

   ISTACK PSTACK XSTACK Function
   ------ ------ ------ --------
       0      0     31  cleanErasedPage
                          0 0 15 -> HalFlashRead
                          0 0 13 -> erasePage
       0      0     52  compactPage
                          0 0 32 -> HalFlashRead
                          0 0 30 -> erasePage
                          0 0 30 -> findItem
                          0 0 30 -> setActivePage
                          0 0 30 -> writeWord
       0      0     45  erasePage
                          0 0 13 -> HalFlashErase
                          0 0 15 -> HalFlashRead
       0      0     48  findItem
                          0 0 18 -> HalFlashRead
       0      0     34  findOffset
                          0 0 18 -> HalFlashRead
       0      0     18  initNV
                          0 0 18 -> HalFlashRead
                          0 0 16 -> cleanErasedPage
                          0 0 16 -> compactPage
                          0 0 16 -> erasePage
                          0 0 16 -> findOffset
                          0 0 16 -> setActivePage
       0      0     20  osal_snv_compact
                          0 0 20 -> compactPage
                          0 0 20 -> setXferPage
       2      0      0  osal_snv_init
                          2 0  0 -> initNV
       0      0     14  osal_snv_read
                          0 0 14 -> HalFlashRead
                          0 0 12 -> findItem
       0      0     21  osal_snv_write
                          0 0 19 -> HalFlashRead
                          0 0 17 -> compactPage
                          0 0 17 -> findItem
                          0 0 17 -> setXferPage
                          0 0 21 -> writeItem
       0      0     43  setActivePage
                          0 0 13 -> writeWord
       0      0     33  setXferPage
                          0 0 13 -> writeWord
       0      0     47  verifyWordM
                          0 0 22 -> HalFlashRead
                          0 0 22 -> osal_memcmp
       0      0     47  writeItem
                          0 0 26 -> HalFlashWrite
                          0 0 25 -> verifyWordM
                          0 0 24 -> writeWord
       0      0     47  writeWord
                          0 0 17 -> HalFlashWrite
                          0 0 16 -> verifyWordM


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       3  ??Subroutine13_0
       5  ??Subroutine14_0
      10  ??Subroutine15_0
      14  ??Subroutine16_0
       6  ??cleanErasedPage?relay
       6  ??compactPage?relay
       6  ??erasePage?relay
       6  ??findItem?relay
       6  ??findOffset?relay
       6  ??initNV?relay
       6  ??osal_snv_compact?relay
       6  ??osal_snv_init?relay
       6  ??osal_snv_read?relay
       6  ??osal_snv_write?relay
       6  ??setActivePage?relay
       6  ??setXferPage?relay
       6  ??verifyWordM?relay
       6  ??writeItem?relay
       6  ??writeWord?relay
       2  ?Subroutine0
      10  ?Subroutine1
      11  ?Subroutine10
      10  ?Subroutine11
      12  ?Subroutine12
       5  ?Subroutine2
       8  ?Subroutine3
       4  ?Subroutine4
       4  ?Subroutine5
       2  ?Subroutine6
       6  ?Subroutine7
      12  ?Subroutine8
       9  ?Subroutine9
       4  __Constant_100000
       4  __Constant_64
       4  __Constant_ffffffff
    4096  _nvBuf
       1  activePg
      74  cleanErasedPage
     398  compactPage
      82  erasePage
       1  failF
     141  findItem
     101  findOffset
     199  initNV
      94  osal_snv_compact
      23  osal_snv_init
      62  osal_snv_read
     256  osal_snv_write
       2  pgOff
      45  setActivePage
      36  setXferPage
     133  verifyWordM
     240  writeItem
     103  writeWord

 
 2 114 bytes in segment BANKED_CODE
    90 bytes in segment BANK_RELAYS
 4 096 bytes in segment BLENV_ADDRESS_SPACE
    12 bytes in segment XDATA_ROM_C
     4 bytes in segment XDATA_Z
 
 2 204 bytes of CODE  memory
     0 bytes of CONST memory (+ 12 bytes shared)
 4 100 bytes of XDATA memory

Errors: none
Warnings: 1
